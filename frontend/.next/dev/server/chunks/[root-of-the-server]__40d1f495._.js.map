{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["\r\n\r\nimport { PrismaClient, type Prisma } from \"@prisma/client\";\r\n\r\ntype GlobalWithPrisma = typeof globalThis & {\r\n  prisma?: PrismaClient;\r\n};\r\n\r\n// Use the global object available in this runtime (node, edge, etc.)\r\nconst _global = globalThis as GlobalWithPrisma;\r\n\r\n// Decide whether we want query logging enabled.\r\n// This is intentionally opt-in via DEV_LOG_QUERIES to avoid noisy logs in normal dev.\r\nconst enableQueryLogging =\r\n  process.env.DEV_LOG_QUERIES === \"true\" && process.env.NODE_ENV !== \"production\";\r\n\r\nconst prismaOptions: Prisma.PrismaClientOptions = enableQueryLogging\r\n  ? { log: [\"query\"] }\r\n  : {};\r\n\r\n// Create or reuse the PrismaClient instance\r\nconst client = _global.prisma ?? new PrismaClient(prismaOptions);\r\n\r\n// In non-production environments, attach to global to avoid new clients on HMR\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  _global.prisma = client;\r\n}\r\n\r\n/**\r\n * Export named and default to be compatible with both import styles.\r\n */\r\nexport const prisma = client;\r\nexport default prisma;\r\n"],"names":[],"mappings":";;;;;;AAEA;;AAMA,qEAAqE;AACrE,MAAM,UAAU;AAEhB,gDAAgD;AAChD,sFAAsF;AACtF,MAAM,qBACJ,QAAQ,GAAG,CAAC,eAAe,KAAK,UAAU,oDAAyB;AAErE,MAAM,gBAA4C,qBAC9C;IAAE,KAAK;QAAC;KAAQ;AAAC,IACjB,CAAC;AAEL,4CAA4C;AAC5C,MAAM,SAAS,QAAQ,MAAM,IAAI,IAAI,6IAAY,CAAC;AAElD,+EAA+E;AAC/E,wCAA2C;IACzC,QAAQ,MAAM,GAAG;AACnB;AAKO,MAAM,SAAS;uCACP","debugId":null}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\n// Keep legacy cookie names to support older sessions during migration.\r\n// Order matters: prefer 'session' then fallbacks.\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"] as const;\r\n\r\ntype TokenPayload = {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  // allow other claims but keep them optional/unknown\r\n  [k: string]: any;\r\n};\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n *\r\n * - Ensures a canonical `id` claim is present when provided in the payload.\r\n * - Copies `email` and `role` when present.\r\n * - Accepts `expiresIn` in jsonwebtoken format (\"7d\", \"1h\", etc).\r\n *\r\n * NOTE: Do not include sensitive data (password hashes, secrets) in token payload.\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: TokenPayload = {};\r\n\r\n  // Accept common id fallback keys for compatibility\r\n  const providedId = payload?.id ?? payload?.userId ?? payload?.sub ?? payload?.uid ?? null;\r\n  if (providedId) finalPayload.id = String(providedId);\r\n\r\n  if (payload?.email) finalPayload.email = payload.email;\r\n  if (payload?.role) finalPayload.role = payload.role;\r\n\r\n  // If you need extra claims (exp, aud, etc), add intentionally here.\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return decoded payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch (err: any) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", err?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. Returns boolean. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(\"[auth] verifyPassword error:\", err);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) OR a list of well-known cookies.\r\n * Returns the canonical user record { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (Next.js route/middleware).\r\n *\r\n * - Prefers Authorization Bearer token.\r\n * - Falls back through COOKIE_CANDIDATES (in order) and returns the first matching user.\r\n * - Accepts older tokens with sub/userId/uid claims for migration.\r\n *\r\n * Important: we fetch the user from the DB each time to ensure role and existence are canonical.\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // NextRequest cookie API: req.cookies.get(name) returns { name, value } | undefined\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie probe: ${name} => missing`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          }\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on cookie access — continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n          console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used inside route handlers.\r\n *\r\n * Example:\r\n *   const user = await requireRole(req, ['admin']);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/auth/login/route.ts"],"sourcesContent":["// src/app/api/auth/login/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifyPassword, signToken } from \"@/lib/auth\";\r\n\r\n/**\r\n * POST /api/auth/login\r\n *\r\n * Accepts: { email, password }\r\n * - Blocks credential login for OAuth-only accounts.\r\n * - Parses legacy provider strings (comma separated).\r\n * - Sets an httpOnly session cookie named \"session\".\r\n */\r\n\r\nconst SESSION_COOKIE_NAME = \"session\";\r\nconst SESSION_MAX_AGE = 7 * 24 * 60 * 60; // 7 days\r\n\r\nfunction jsonError(msg: string, status = 400) {\r\n  return NextResponse.json({ ok: false, error: msg }, { status });\r\n}\r\n\r\n/** Parse provider field into normalized array (handles comma-lists, nulls) */\r\nfunction parseProviders(providerField: string | null | undefined): string[] {\r\n  if (!providerField) return [];\r\n  return providerField\r\n    .toString()\r\n    .split(\",\")\r\n    .map((p) => p.trim().toLowerCase())\r\n    .filter(Boolean);\r\n}\r\n\r\n/**\r\n * Build fallback Set-Cookie header value. In production use SameSite=None + Secure\r\n * so cookies work across sites (if that's your intended deployment). In non-prod use Lax.\r\n */\r\nfunction buildCookieHeader(name: string, value: string, maxAge = SESSION_MAX_AGE) {\r\n  const isProd = process.env.NODE_ENV === \"production\";\r\n  const sameSite = isProd ? \"None\" : \"Lax\";\r\n  const secure = !!isProd;\r\n  const parts = [\r\n    `${name}=${encodeURIComponent(value)}`,\r\n    \"Path=/\",\r\n    `Max-Age=${maxAge}`,\r\n    \"HttpOnly\",\r\n    `SameSite=${sameSite}`,\r\n    secure ? \"Secure\" : \"\",\r\n  ].filter(Boolean);\r\n  return parts.join(\"; \");\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = (await req.json().catch(() => ({} as any))) as { email?: string; password?: string };\r\n    const rawEmail = (body?.email ?? \"\").toString();\r\n    const password = (body?.password ?? \"\").toString();\r\n\r\n    const email = rawEmail.trim().toLowerCase();\r\n    if (!email || !password) {\r\n      return jsonError(\"Email and password are required.\", 400);\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { email },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        passwordHash: true,\r\n        role: true,\r\n        provider: true,\r\n      },\r\n    });\r\n\r\n    // Do not reveal whether email exists\r\n    if (!user) return jsonError(\"Invalid email or password.\", 401);\r\n\r\n    // Robust provider parsing\r\n    const providers = parseProviders(user.provider as string | null | undefined);\r\n    const hasCredentials =\r\n      providers.includes(\"credentials\") ||\r\n      providers.includes(\"email\") ||\r\n      providers.includes(\"local\") ||\r\n      !!user.passwordHash;\r\n\r\n    const oauthProviders = providers.filter((p) => p !== \"credentials\" && p !== \"email\" && p !== \"local\");\r\n\r\n    // If user does NOT have credentials, but has external provider(s) — block credential login\r\n    if (!hasCredentials) {\r\n      const providerLabel = oauthProviders.length ? oauthProviders.join(\", \") : \"an external provider\";\r\n      return NextResponse.json(\r\n        {\r\n          ok: false,\r\n          error: `This account was created using ${providerLabel}. Please sign in with ${providerLabel} or link credentials from account settings.`,\r\n        },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    if (!user.passwordHash) {\r\n      // Defensive: if provider claims credentials but no password is stored\r\n      return jsonError(\"Password not set for this account. Please reset your password.\", 401);\r\n    }\r\n\r\n    const valid = await verifyPassword(password, user.passwordHash);\r\n    if (!valid) return jsonError(\"Invalid email or password.\", 401);\r\n\r\n    // Create session token (7d) — include canonical role from DB\r\n    const token = signToken({ id: user.id, email: user.email, role: user.role }, \"7d\");\r\n\r\n    // Fire-and-forget activity log (non-blocking)\r\n    (async () => {\r\n      try {\r\n        await prisma.activityLog.create({\r\n          data: {\r\n            userId: user.id,\r\n            type: \"LOGIN\",\r\n            meta: { provider: \"credentials\", ts: new Date().toISOString() },\r\n          },\r\n        });\r\n      } catch (e) {\r\n        console.error(\"⚠️ Failed to record login activity:\", e);\r\n      }\r\n    })();\r\n\r\n    const res = NextResponse.json({\r\n      ok: true,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        name: user.name,\r\n        role: user.role,\r\n        provider: providers.length ? providers.join(\",\") : \"credentials\",\r\n      },\r\n    });\r\n\r\n    // Prefer NextResponse cookies API; fall back to Set-Cookie header if necessary\r\n    try {\r\n      // Use NextResponse cookies API when runtime supports it\r\n      res.cookies.set(SESSION_COOKIE_NAME, token, {\r\n        httpOnly: true,\r\n        sameSite: \"lax\",\r\n        secure: process.env.NODE_ENV === \"production\",\r\n        path: \"/\",\r\n        maxAge: SESSION_MAX_AGE,\r\n      } as any);\r\n    } catch {\r\n      // Fallback header — set SameSite=None in prod (to match typical cross-site usage), Lax otherwise\r\n      res.headers.set(\"Set-Cookie\", buildCookieHeader(SESSION_COOKIE_NAME, token, SESSION_MAX_AGE));\r\n    }\r\n\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth/login] session cookie set for userId:\", user.id);\r\n    }\r\n\r\n    return res;\r\n  } catch (err) {\r\n    console.error(\"❌ Login error:\", err);\r\n    return jsonError(\"Internal server error.\", 500);\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}