{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\n// Keep legacy cookie names to support older sessions during migration.\r\n// Order matters: prefer 'session' then fallbacks.\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"] as const;\r\n\r\ntype TokenPayload = {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  // allow other claims but keep them optional/unknown\r\n  [k: string]: any;\r\n};\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n *\r\n * - Ensures a canonical `id` claim is present when provided in the payload.\r\n * - Copies `email` and `role` when present.\r\n * - Accepts `expiresIn` in jsonwebtoken format (\"7d\", \"1h\", etc).\r\n *\r\n * NOTE: Do not include sensitive data (password hashes, secrets) in token payload.\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: TokenPayload = {};\r\n\r\n  // Accept common id fallback keys for compatibility\r\n  const providedId = payload?.id ?? payload?.userId ?? payload?.sub ?? payload?.uid ?? null;\r\n  if (providedId) finalPayload.id = String(providedId);\r\n\r\n  if (payload?.email) finalPayload.email = payload.email;\r\n  if (payload?.role) finalPayload.role = payload.role;\r\n\r\n  // If you need extra claims (exp, aud, etc), add intentionally here.\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return decoded payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch (err: any) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", err?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. Returns boolean. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(\"[auth] verifyPassword error:\", err);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) OR a list of well-known cookies.\r\n * Returns the canonical user record { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (Next.js route/middleware).\r\n *\r\n * - Prefers Authorization Bearer token.\r\n * - Falls back through COOKIE_CANDIDATES (in order) and returns the first matching user.\r\n * - Accepts older tokens with sub/userId/uid claims for migration.\r\n *\r\n * Important: we fetch the user from the DB each time to ensure role and existence are canonical.\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // NextRequest cookie API: req.cookies.get(name) returns { name, value } | undefined\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie probe: ${name} => missing`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          }\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on cookie access â€” continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n          console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used inside route handlers.\r\n *\r\n * Example:\r\n *   const user = await requireRole(req, ['admin']);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 272, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/auth/signup/route.ts"],"sourcesContent":["// src/app/api/auth/signup/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { hashPassword, signToken } from \"@/lib/auth\";\r\n\r\ntype ReqBody = {\r\n  email?: string;\r\n  name?: string;\r\n  password?: string;\r\n  // client-sent role will be normalized server-side\r\n  role?: string;\r\n  provider?: \"credentials\" | \"google\" | string;\r\n};\r\n\r\n/** Env-aware cookie setter helper (uses res.cookies.set when available, header fallback otherwise) */\r\nfunction setSessionCookie(res: NextResponse, token: string) {\r\n  const isProd = process.env.NODE_ENV === \"production\";\r\n  const sameSite = isProd ? \"none\" : \"lax\";\r\n  const secure = isProd;\r\n  const maxAge = 7 * 24 * 60 * 60; // 7 days\r\n\r\n  try {\r\n    res.cookies.set({\r\n      name: \"session\",\r\n      value: token,\r\n      httpOnly: true,\r\n      secure,\r\n      sameSite: sameSite as \"lax\" | \"none\" | \"strict\",\r\n      path: \"/\",\r\n      maxAge,\r\n    });\r\n  } catch {\r\n    // header fallback for runtimes that expect a Set-Cookie header string\r\n    const parts = [\r\n      `session=${encodeURIComponent(token)}`,\r\n      \"Path=/\",\r\n      `Max-Age=${maxAge}`,\r\n      \"HttpOnly\",\r\n      isProd ? \"SameSite=None\" : \"SameSite=Lax\",\r\n      secure ? \"Secure\" : \"\",\r\n    ].filter(Boolean);\r\n    res.headers.set(\"Set-Cookie\", parts.join(\"; \"));\r\n  }\r\n}\r\n\r\n/** Normalize a client-provided role into the Prisma enum value (uppercase) */\r\nfunction normalizeRoleForDb(raw?: string | null) {\r\n  if (!raw) return \"VIEWER\";\r\n  const v = String(raw).trim();\r\n  if ([\"VIEWER\", \"EDITOR\", \"ADMIN\"].includes(v)) return v;\r\n  const lower = v.toLowerCase();\r\n  if (lower === \"viewer\") return \"VIEWER\";\r\n  if (lower === \"editor\") return \"EDITOR\";\r\n  if (lower === \"admin\") return \"ADMIN\";\r\n  return \"VIEWER\";\r\n}\r\n\r\n/** Helper: check whether any admin exists (uses provided tx if present) */\r\nasync function adminExistsTx(tx?: typeof prisma) {\r\n  const p = tx ?? prisma;\r\n  // Use a raw SQL check to avoid enum validation conflicts; returns boolean\r\n  try {\r\n    const result = await p.$queryRaw<Array<{ count: number }>>`SELECT COUNT(*)::int AS count FROM \"User\" WHERE LOWER(role::text) = 'admin'`;\r\n    return (result?.[0]?.count ?? 0) > 0;\r\n  } catch (err) {\r\n    console.error(\"[signup] adminExistsTx fallback query error:\", err);\r\n    // conservative default: assume admin exists to avoid accidental duplicate admin creation\r\n    return true;\r\n  }\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = (await req.json()) as ReqBody;\r\n    const rawEmail = body.email;\r\n    const name = (body.name || \"\").toString().trim();\r\n    const password = body.password;\r\n    const provider = (body.provider || \"credentials\").toString();\r\n\r\n    const email = (rawEmail || \"\").toString().trim().toLowerCase();\r\n\r\n    if (!email || !name) {\r\n      return NextResponse.json(\r\n        { error: \"Missing required fields: name and email are required.\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (![\"credentials\", \"google\"].includes(provider)) {\r\n      return NextResponse.json(\r\n        { error: \"Unsupported provider. Use 'credentials' or 'google'.\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Normalize requested role (client may send viewer/editor/admin in any case)\r\n    const requestedRoleRaw = (body.role || \"\").toString().trim();\r\n    const requestedRoleForDb = normalizeRoleForDb(requestedRoleRaw); // e.g. \"VIEWER\"|\"EDITOR\"|\"ADMIN\"\r\n\r\n    // If user already exists -> conflict (for OAuth flows you may want to link instead)\r\n    const existing = await prisma.user.findUnique({ where: { email } });\r\n    if (existing) {\r\n      return NextResponse.json(\r\n        { error: \"User already exists with this email\" },\r\n        { status: 409 }\r\n      );\r\n    }\r\n\r\n    // ---------- Credentials signup (email + password + OTP verified) ----------\r\n    if (provider === \"credentials\") {\r\n      if (!password) {\r\n        return NextResponse.json(\r\n          { error: \"Password required for credentials signup\" },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      // Check most recent OTP for this email\r\n      const otp = await prisma.emailOtp.findFirst({\r\n        where: { email },\r\n        orderBy: { createdAt: \"desc\" },\r\n      });\r\n\r\n      if (!otp || !otp.verified) {\r\n        return NextResponse.json(\r\n          { error: \"Email not verified with OTP\" },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      const passwordHash = await hashPassword(password);\r\n\r\n      // If requested role is ADMIN -> perform atomic check+create using a transaction\r\n      if (requestedRoleForDb === \"ADMIN\") {\r\n        try {\r\n          const result = await prisma.$transaction(async (tx) => {\r\n            const exists = await adminExistsTx(tx);\r\n            if (exists) {\r\n              // signal admin exists by throwing a sentinel\r\n              throw { code: \"ADMIN_EXISTS\" };\r\n            }\r\n            const user = await tx.user.create({\r\n              data: {\r\n                email,\r\n                name,\r\n                passwordHash,\r\n                role: \"ADMIN\",\r\n                emailVerified: true,\r\n                provider: \"credentials\",\r\n              },\r\n              select: { id: true, email: true, name: true, role: true, provider: true },\r\n            });\r\n            // cleanup OTPs inside same tx if desired (optional)\r\n            await tx.emailOtp.deleteMany({ where: { email } });\r\n            return user;\r\n          });\r\n\r\n          const token = signToken({ id: result.id, email: result.email, role: result.role }, \"7d\");\r\n          const res = NextResponse.json({ ok: true, user: result });\r\n          setSessionCookie(res, token);\r\n          return res;\r\n        } catch (err) {\r\n          if (err && err.code === \"ADMIN_EXISTS\") {\r\n            return NextResponse.json({ error: \"An admin account already exists\" }, { status: 409 });\r\n          }\r\n          console.error(\"signup (credentials/admin) transaction error:\", err);\r\n          return NextResponse.json({ error: \"Server error\" }, { status: 500 });\r\n        }\r\n      }\r\n\r\n      // Non-admin create path (viewer/editor)\r\n      const user = await prisma.user.create({\r\n        data: {\r\n          email,\r\n          name,\r\n          passwordHash,\r\n          role: requestedRoleForDb, // 'VIEWER' or 'EDITOR'\r\n          emailVerified: true,\r\n          provider: \"credentials\",\r\n        },\r\n        select: { id: true, email: true, name: true, role: true, provider: true },\r\n      });\r\n\r\n      // Remove OTP records for cleanup\r\n      await prisma.emailOtp.deleteMany({ where: { email } });\r\n\r\n      // Sign token with id, email, role\r\n      const token = signToken({ id: user.id, email: user.email, role: user.role }, \"7d\");\r\n\r\n      const res = NextResponse.json({ ok: true, user });\r\n\r\n      // set cookie in env-aware way\r\n      setSessionCookie(res, token);\r\n\r\n      return res;\r\n    }\r\n\r\n    // ---------- Google OAuth signup ----------\r\n    if (provider === \"google\") {\r\n      // For OAuth you typically verify the Google token on the server before creating.\r\n      // Here we assume upstream verification was done and we just create the account.\r\n\r\n      // If requested role is ADMIN -> atomic check+create\r\n      if (requestedRoleForDb === \"ADMIN\") {\r\n        try {\r\n          const result = await prisma.$transaction(async (tx) => {\r\n            const exists = await adminExistsTx(tx);\r\n            if (exists) {\r\n              throw { code: \"ADMIN_EXISTS\" };\r\n            }\r\n            const user = await tx.user.create({\r\n              data: {\r\n                email,\r\n                name,\r\n                passwordHash: null,\r\n                role: \"ADMIN\",\r\n                emailVerified: true,\r\n                provider: \"google\",\r\n              },\r\n              select: { id: true, email: true, name: true, role: true, provider: true },\r\n            });\r\n            await tx.account.create({\r\n              data: {\r\n                provider: \"google\",\r\n                providerAccountId: body?.role ? String(body.role) : String(body.email), // placeholder if needed\r\n                userId: user.id,\r\n              },\r\n            }).catch(() => {}); // optional: ignore if account table not used here\r\n            return user;\r\n          });\r\n\r\n          const token = signToken({ id: result.id, email: result.email, role: result.role }, \"7d\");\r\n          const res = NextResponse.json({ ok: true, user: result });\r\n          setSessionCookie(res, token);\r\n          return res;\r\n        } catch (err) {\r\n          if (err && err.code === \"ADMIN_EXISTS\") {\r\n            return NextResponse.json({ error: \"An admin account already exists\" }, { status: 409 });\r\n          }\r\n          console.error(\"google signup error (admin path):\", err);\r\n          return NextResponse.json({ error: \"Server error\" }, { status: 500 });\r\n        }\r\n      }\r\n\r\n      // Non-admin google create path\r\n      const user = await prisma.user.create({\r\n        data: {\r\n          email,\r\n          name,\r\n          passwordHash: null,\r\n          role: requestedRoleForDb, // VIEWER or EDITOR\r\n          emailVerified: true,\r\n          provider: \"google\",\r\n        },\r\n        select: { id: true, email: true, name: true, role: true, provider: true },\r\n      });\r\n\r\n      const token = signToken({ id: user.id, email: user.email, role: user.role }, \"7d\");\r\n\r\n      const res = NextResponse.json({ ok: true, user });\r\n      setSessionCookie(res, token);\r\n      return res;\r\n    }\r\n\r\n    return NextResponse.json({ error: \"Unsupported provider\" }, { status: 400 });\r\n  } catch (err: any) {\r\n    // special-case thrown admin-exists signal from transaction\r\n    if (err && err.code === \"ADMIN_EXISTS\") {\r\n      return NextResponse.json({ error: \"An admin account already exists\" }, { status: 409 });\r\n    }\r\n    console.error(\"signup error:\", err);\r\n    return NextResponse.json({ error: \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}