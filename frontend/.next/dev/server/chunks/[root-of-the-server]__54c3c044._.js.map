{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///E:/SignalHub/frontend/src/app/api/auth/verify-otp/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport bcrypt from \"bcrypt\";\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const { email, code } = await req.json();\r\n\r\n    if (!email || !code) {\r\n      return NextResponse.json({ error: \"Email and code required\" }, { status: 400 });\r\n    }\r\n\r\n    // Option 1: if email is @unique\r\n    // const otp = await prisma.emailOtp.findUnique({ where: { email } });\r\n\r\n    // Option 2: if multiple OTPs per email allowed\r\n   const otp = await prisma.emailOtp.findFirst({\r\n  where: { email },\r\n  orderBy: { createdAt: 'desc' }, // get the latest OTP\r\n});\r\n\r\n    if (!otp) {\r\n      return NextResponse.json({ error: \"No OTP found for this email\" }, { status: 404 });\r\n    }\r\n\r\n    if (otp.verified) {\r\n      return NextResponse.json({ ok: true, message: \"Already verified\" });\r\n    }\r\n\r\n    const isMatch = await bcrypt.compare(code, otp.codeHash);\r\n    if (!isMatch) {\r\n      return NextResponse.json({ error: \"Invalid OTP\" }, { status: 401 });\r\n    }\r\n\r\n    if (new Date() > otp.expiresAt) {\r\n      return NextResponse.json({ error: \"OTP expired\" }, { status: 400 });\r\n    }\r\n\r\n    await prisma.emailOtp.update({\r\n      where: { id: otp.id },\r\n      data: { verified: true },\r\n    });\r\n\r\n    return NextResponse.json({ ok: true, message: \"OTP verified\" });\r\n  } catch (err) {\r\n    console.error(\"verify-otp error:\", err);\r\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI,IAAI;QAEtC,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,gCAAgC;QAChC,sEAAsE;QAEtE,+CAA+C;QAChD,MAAM,MAAM,MAAM,gIAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;YAC7C,OAAO;gBAAE;YAAM;YACf,SAAS;gBAAE,WAAW;YAAO;QAC/B;QAEI,IAAI,CAAC,KAAK;YACR,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA8B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,IAAI,IAAI,QAAQ,EAAE;YAChB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,IAAI;gBAAM,SAAS;YAAmB;QACnE;QAEA,MAAM,UAAU,MAAM,gHAAM,CAAC,OAAO,CAAC,MAAM,IAAI,QAAQ;QACvD,IAAI,CAAC,SAAS;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAc,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,IAAI,IAAI,SAAS,IAAI,SAAS,EAAE;YAC9B,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAc,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,MAAM,gIAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;YAC3B,OAAO;gBAAE,IAAI,IAAI,EAAE;YAAC;YACpB,MAAM;gBAAE,UAAU;YAAK;QACzB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM,SAAS;QAAe;IAC/D,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF","debugId":null}}]
}