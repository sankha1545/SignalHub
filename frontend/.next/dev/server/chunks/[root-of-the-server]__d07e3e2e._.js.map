{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\n// Keep legacy cookie names to support older sessions during migration.\r\n// Order matters: prefer 'session' then fallbacks.\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"] as const;\r\n\r\ntype TokenPayload = {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  // allow other claims but keep them optional/unknown\r\n  [k: string]: any;\r\n};\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n *\r\n * - Ensures a canonical `id` claim is present when provided in the payload.\r\n * - Copies `email` and `role` when present.\r\n * - Accepts `expiresIn` in jsonwebtoken format (\"7d\", \"1h\", etc).\r\n *\r\n * NOTE: Do not include sensitive data (password hashes, secrets) in token payload.\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: TokenPayload = {};\r\n\r\n  // Accept common id fallback keys for compatibility\r\n  const providedId = payload?.id ?? payload?.userId ?? payload?.sub ?? payload?.uid ?? null;\r\n  if (providedId) finalPayload.id = String(providedId);\r\n\r\n  if (payload?.email) finalPayload.email = payload.email;\r\n  if (payload?.role) finalPayload.role = payload.role;\r\n\r\n  // If you need extra claims (exp, aud, etc), add intentionally here.\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return decoded payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch (err: any) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", err?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. Returns boolean. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(\"[auth] verifyPassword error:\", err);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) OR a list of well-known cookies.\r\n * Returns the canonical user record { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (Next.js route/middleware).\r\n *\r\n * - Prefers Authorization Bearer token.\r\n * - Falls back through COOKIE_CANDIDATES (in order) and returns the first matching user.\r\n * - Accepts older tokens with sub/userId/uid claims for migration.\r\n *\r\n * Important: we fetch the user from the DB each time to ensure role and existence are canonical.\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // NextRequest cookie API: req.cookies.get(name) returns { name, value } | undefined\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie probe: ${name} => missing`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          }\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on cookie access — continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n          console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used inside route handlers.\r\n *\r\n * Example:\r\n *   const user = await requireRole(req, ['admin']);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/messages/send/route.ts"],"sourcesContent":["// src/app/api/messages/send/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET ?? \"dev-secret\";\r\n\r\ntype Incoming = {\r\n  to?: string;\r\n  channel?: string;\r\n  body?: string;\r\n  scheduleAt?: string | null;\r\n  contactId?: string | null; // may be a Thread id or contact id depending on your model\r\n  metadata?: any;\r\n};\r\n\r\nfunction devLog(...args: any[]) {\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    // eslint-disable-next-line no-console\r\n    console.debug(\"[/api/messages/send]\", ...args);\r\n  }\r\n}\r\n\r\n/** Try to import NextAuth's getServerSession + your authOptions (optional) */\r\n// near top of file\r\nlet getServerSession: any = null;\r\nlet authOptions: any = null;\r\ntry {\r\n  // require to avoid bundling mismatch issues\r\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n  const nextAuth = require(\"next-auth\");\r\n  getServerSession = nextAuth.getServerSession;\r\n  // adjust this path if your authOptions lives elsewhere\r\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n  authOptions = require(\"@/lib/auth\").authOptions;\r\n} catch (e) {\r\n  console.debug(\"NextAuth not available or authOptions import failed:\", e);\r\n}\r\n\r\n// inside POST handler, try NextAuth session first:\r\nif (!resolvedUserId && getServerSession && authOptions) {\r\n  try {\r\n    // App Router usage: getServerSession(authOptions)\r\n    const session = await getServerSession(authOptions);\r\n    console.debug(\"nextauth session:\", session);\r\n    if (session?.user) {\r\n      // adapt to what you store as identifier (id or email)\r\n      resolvedUserId = session.user.id ?? session.user.email ?? null;\r\n    }\r\n  } catch (e) {\r\n    console.debug(\"getServerSession call failed:\", e);\r\n  }\r\n}\r\n\r\n\r\n/** Extract token from Authorization header or cookies */\r\nfunction extractTokenFromRequest(req: Request): string | null {\r\n  try {\r\n    const auth = req.headers.get(\"authorization\") ?? \"\";\r\n    if (auth && auth.toLowerCase().startsWith(\"bearer \")) {\r\n      return auth.slice(7).trim();\r\n    }\r\n    const cookieHeader = req.headers.get(\"cookie\") ?? \"\";\r\n    if (!cookieHeader) return null;\r\n    const found = cookieHeader\r\n      .split(\";\")\r\n      .map((s) => s.trim())\r\n      .find((s) => s.startsWith(\"token=\"));\r\n    if (!found) return null;\r\n    // token may contain '=' characters, so join after first =\r\n    const idx = found.indexOf(\"=\");\r\n    return idx === -1 ? null : found.slice(idx + 1);\r\n  } catch (e) {\r\n    devLog(\"extractTokenFromRequest error:\", e);\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction verifyJwt(token: string | null) {\r\n  if (!token) return null;\r\n  try {\r\n    // lazy require jsonwebtoken (avoid bundling issues if absent)\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    const jwt = require(\"jsonwebtoken\");\r\n    const decoded: any = jwt.verify(token, JWT_SECRET);\r\n    return decoded;\r\n  } catch (e) {\r\n    devLog(\"JWT verify failed:\", e);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  devLog(\"POST /api/messages/send start\");\r\n\r\n  // parse body\r\n  let bodyParsed: Incoming | null = null;\r\n  try {\r\n    bodyParsed = (await req.json()) as Incoming;\r\n  } catch (err) {\r\n    devLog(\"failed to parse JSON body:\", err);\r\n    return NextResponse.json({ error: \"Invalid JSON\" }, { status: 400 });\r\n  }\r\n  devLog(\"payload:\", bodyParsed);\r\n\r\n  // === AUTH RESOLUTION ===\r\n  let resolvedUserId: string | null = null; // may be DB id or email depending on your auth\r\n  try {\r\n    if (getServerSession && authOptions) {\r\n      try {\r\n        // App Router getServerSession usage (may vary per NextAuth version)\r\n        const session = await getServerSession(authOptions);\r\n        devLog(\"NextAuth session:\", session);\r\n        if (session?.user) {\r\n          // adapt to your session shape (id/email)\r\n          resolvedUserId = session.user.id ?? session.user.email ?? null;\r\n        }\r\n      } catch (e) {\r\n        devLog(\"getServerSession call threw:\", e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    devLog(\"NextAuth flow failed:\", e);\r\n  }\r\n\r\n  // fallback: check Authorization / cookie JWT\r\n  if (!resolvedUserId) {\r\n    const token = extractTokenFromRequest(req);\r\n    const decoded = verifyJwt(token);\r\n    devLog(\"token present?\", !!token, \"decoded:\", decoded);\r\n    if (decoded) {\r\n      // adapt field names: prefer `sub`, `id`, `userId`, `email`\r\n      resolvedUserId = decoded.sub ?? decoded.id ?? decoded.userId ?? decoded.email ?? null;\r\n    }\r\n  }\r\n\r\n  if (!resolvedUserId) {\r\n    devLog(\"Auth failed — no user resolved\");\r\n    return NextResponse.json({ error: \"Not authenticated\" }, { status: 401 });\r\n  }\r\n  devLog(\"resolvedUserId:\", resolvedUserId);\r\n\r\n  // === BASIC VALIDATION ===\r\n  const to = typeof bodyParsed?.to === \"string\" ? bodyParsed.to.trim() : null;\r\n  const channel = typeof bodyParsed?.channel === \"string\" ? bodyParsed.channel.trim().toUpperCase() : null;\r\n  const messageBody = typeof bodyParsed?.body === \"string\" ? bodyParsed.body.trim() : null;\r\n  const scheduleAt = typeof bodyParsed?.scheduleAt === \"string\" ? bodyParsed.scheduleAt : null;\r\n  const contactId = typeof bodyParsed?.contactId === \"string\" ? bodyParsed.contactId : null;\r\n  const metadata = bodyParsed?.metadata ?? {};\r\n\r\n  if (!to || !channel || !messageBody) {\r\n    return NextResponse.json({ error: \"Missing required fields (to, channel, body)\" }, { status: 400 });\r\n  }\r\n\r\n  const allowed = [\"SMS\", \"WHATSAPP\", \"EMAIL\"];\r\n  if (!allowed.includes(channel)) {\r\n    return NextResponse.json({ error: \"Unsupported channel\" }, { status: 400 });\r\n  }\r\n\r\n  // === THREAD resolution/creation ===\r\n  let thread: any = null;\r\n  try {\r\n    if (contactId) {\r\n      // Try to treat contactId as a thread id first\r\n      try {\r\n        thread = await prisma.thread.findUnique({ where: { id: contactId } });\r\n      } catch (e) {\r\n        devLog(\"prisma.thread.findUnique threw (contactId):\", e);\r\n        thread = null;\r\n      }\r\n    }\r\n\r\n    if (!thread) {\r\n      // Optionally try to find thread by a uniqueness key (e.g. participants/to/metadata) - omitted here\r\n      // Create a minimal thread to associate messages with\r\n      try {\r\n        thread = await prisma.thread.create({\r\n          data: {\r\n            title: `Thread for ${to}`,\r\n            contactId: contactId ?? null,\r\n            // you may want to set createdBy/respective fields — adapt to your schema\r\n            createdBy: String(resolvedUserId),\r\n          } as any,\r\n        });\r\n        devLog(\"created thread:\", thread?.id ?? \"(no id)\");\r\n      } catch (createErr) {\r\n        devLog(\"prisma.thread.create failed:\", createErr);\r\n        // If creating a thread fails and your schema requires connecting nested relations differently,\r\n        // we'll still try to proceed with a message that has no threadId if your schema allows it.\r\n        thread = null;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    devLog(\"thread resolution error:\", e);\r\n    thread = null;\r\n  }\r\n\r\n  // === CREATE MESSAGE ===\r\n  try {\r\n    // Build message data; adapt fieldnames to your schema\r\n    const messageData: any = {\r\n      senderId: String(resolvedUserId),\r\n      body: messageBody,\r\n      channel,\r\n      direction: \"OUTBOUND\",\r\n      metadata: { ...(typeof metadata === \"object\" ? metadata : { to }), to },\r\n      scheduledAt: scheduleAt ? new Date(scheduleAt) : null,\r\n    };\r\n\r\n    // Attach thread either by threadId (if nullable) or by connect (if your schema requires relation)\r\n    if (thread && thread.id) {\r\n      // Some Prisma schemas accept threadId directly; others require nested connect.\r\n      // We'll try direct threadId first, fallback to nested connect if that errors.\r\n      try {\r\n        messageData.threadId = thread.id;\r\n        const message = await prisma.message.create({ data: messageData as any });\r\n        devLog(\"message created (threadId):\", message?.id ?? \"(no id)\");\r\n        return NextResponse.json({ ok: true, message, thread });\r\n      } catch (errThreadId) {\r\n        devLog(\"prisma.message.create with threadId failed, will try nested connect:\", errThreadId);\r\n        // try nested connect\r\n        try {\r\n          const message = await prisma.message.create({\r\n            data: {\r\n              ...messageData,\r\n              thread: { connect: { id: thread.id } },\r\n            } as any,\r\n          });\r\n          devLog(\"message created (nested connect):\", message?.id ?? \"(no id)\");\r\n          return NextResponse.json({ ok: true, message, thread });\r\n        } catch (errNested) {\r\n          devLog(\"prisma.message.create nested connect also failed:\", errNested);\r\n          // fall through to last-resort attempt below\r\n        }\r\n      }\r\n    }\r\n\r\n    // Last-resort attempt: create message without thread relation (if schema allows)\r\n    try {\r\n      const message = await prisma.message.create({ data: messageData as any });\r\n      devLog(\"message created without thread:\", message?.id ?? \"(no id)\");\r\n      return NextResponse.json({ ok: true, message, thread: null });\r\n    } catch (finalErr) {\r\n      devLog(\"prisma.message.create final attempt failed:\", finalErr);\r\n      return NextResponse.json({ error: \"Internal server error (message create failed)\" }, { status: 500 });\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] unexpected error:\", err);\r\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}