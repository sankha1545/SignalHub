{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["\r\n\r\nimport { PrismaClient, type Prisma } from \"@prisma/client\";\r\n\r\ntype GlobalWithPrisma = typeof globalThis & {\r\n  prisma?: PrismaClient;\r\n};\r\n\r\n// Use the global object available in this runtime (node, edge, etc.)\r\nconst _global = globalThis as GlobalWithPrisma;\r\n\r\n// Decide whether we want query logging enabled.\r\n// This is intentionally opt-in via DEV_LOG_QUERIES to avoid noisy logs in normal dev.\r\nconst enableQueryLogging =\r\n  process.env.DEV_LOG_QUERIES === \"true\" && process.env.NODE_ENV !== \"production\";\r\n\r\nconst prismaOptions: Prisma.PrismaClientOptions = enableQueryLogging\r\n  ? { log: [\"query\"] }\r\n  : {};\r\n\r\n// Create or reuse the PrismaClient instance\r\nconst client = _global.prisma ?? new PrismaClient(prismaOptions);\r\n\r\n// In non-production environments, attach to global to avoid new clients on HMR\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  _global.prisma = client;\r\n}\r\n\r\n/**\r\n * Export named and default to be compatible with both import styles.\r\n */\r\nexport const prisma = client;\r\nexport default prisma;\r\n"],"names":[],"mappings":";;;;;;AAEA;;AAMA,qEAAqE;AACrE,MAAM,UAAU;AAEhB,gDAAgD;AAChD,sFAAsF;AACtF,MAAM,qBACJ,QAAQ,GAAG,CAAC,eAAe,KAAK,UAAU,oDAAyB;AAErE,MAAM,gBAA4C,qBAC9C;IAAE,KAAK;QAAC;KAAQ;AAAC,IACjB,CAAC;AAEL,4CAA4C;AAC5C,MAAM,SAAS,QAAQ,MAAM,IAAI,IAAI,6IAAY,CAAC;AAElD,+EAA+E;AAC/E,wCAA2C;IACzC,QAAQ,MAAM,GAAG;AACnB;AAKO,MAAM,SAAS;uCACP","debugId":null}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/providers/twilio.ts"],"sourcesContent":["// src/lib/providers/twilio.ts\r\nimport Twilio from \"twilio\";\r\n\r\nconst SID = process.env.TWILIO_SID ?? \"\";\r\nconst AUTH = process.env.TWILIO_AUTH_TOKEN ?? \"\";\r\nconst FROM = process.env.TWILIO_PHONE_NUMBER ?? \"\";\r\nconst WA_FROM = process.env.TWILIO_WHATSAPP_NUMBER ?? \"\";\r\n\r\nconst client = SID && AUTH ? Twilio(SID, AUTH) : null;\r\n\r\nexport async function sendSms({ to, body }: { to: string; body: string }) {\r\n  if (!client) throw new Error(\"Twilio not configured\");\r\n  const msg = await client.messages.create({ body, from: FROM, to });\r\n  return { sid: msg.sid, status: msg.status };\r\n}\r\n\r\nexport async function sendWhatsApp({ to, body }: { to: string; body: string }) {\r\n  if (!client) throw new Error(\"Twilio not configured\");\r\n  const msg = await client.messages.create({\r\n    body,\r\n    from: `whatsapp:${WA_FROM}`,\r\n    to: `whatsapp:${to.replace(/^whatsapp:/, \"\")}`,\r\n  });\r\n  return { sid: msg.sid, status: msg.status };\r\n}\r\n\r\n/**\r\n * Validate Twilio request signature if you choose to secure webhooks.\r\n * For simplicity this helper returns true if no auth configured.\r\n * If you want to validate, use Twilio.validateRequest with raw body + headers.\r\n */\r\nexport function validateTwilioRequest(/* req raw body & headers */) {\r\n  // implement signature check if required\r\n  return true;\r\n}\r\n"],"names":[],"mappings":"AAAA,8BAA8B;;;;;;;;;AAC9B;;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;AACtC,MAAM,OAAO,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AAC9C,MAAM,OAAO,QAAQ,GAAG,CAAC,mBAAmB,IAAI;AAChD,MAAM,UAAU,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AAEtD,MAAM,SAAS,OAAO,OAAO,IAAA,+JAAM,EAAC,KAAK,QAAQ;AAE1C,eAAe,QAAQ,EAAE,EAAE,EAAE,IAAI,EAAgC;IACtE,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAC7B,MAAM,MAAM,MAAM,OAAO,QAAQ,CAAC,MAAM,CAAC;QAAE;QAAM,MAAM;QAAM;IAAG;IAChE,OAAO;QAAE,KAAK,IAAI,GAAG;QAAE,QAAQ,IAAI,MAAM;IAAC;AAC5C;AAEO,eAAe,aAAa,EAAE,EAAE,EAAE,IAAI,EAAgC;IAC3E,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAC7B,MAAM,MAAM,MAAM,OAAO,QAAQ,CAAC,MAAM,CAAC;QACvC;QACA,MAAM,CAAC,SAAS,EAAE,SAAS;QAC3B,IAAI,CAAC,SAAS,EAAE,GAAG,OAAO,CAAC,cAAc,KAAK;IAChD;IACA,OAAO;QAAE,KAAK,IAAI,GAAG;QAAE,QAAQ,IAAI,MAAM;IAAC;AAC5C;AAOO,SAAS;IACd,wCAAwC;IACxC,OAAO;AACT","debugId":null}},
    {"offset": {"line": 250, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/providers/email.ts"],"sourcesContent":["// src/lib/providers/email.ts\r\nimport type Mail from \"nodemailer/lib/mailer\";\r\nimport nodemailer from \"nodemailer\";\r\n\r\nconst RESEND_KEY = process.env.RESEND_API_KEY ?? \"\";\r\n\r\nexport async function sendEmail({ to, subject, html, text, from }: { to: string; subject?: string; html?: string; text?: string; from?: string }) {\r\n  // If RESEND_API_KEY present you can use Resend's API (not included to avoid extra dep).\r\n  // Fallback to SMTP using nodemailer.\r\n  const fromAddr = from ?? `SignalHub <${process.env.SMTP_USER ?? \"noreply@example.com\"}>`;\r\n\r\n  if (process.env.SMTP_HOST) {\r\n    const transporter = nodemailer.createTransport({\r\n      host: process.env.SMTP_HOST,\r\n      port: Number(process.env.SMTP_PORT ?? 587),\r\n      secure: Number(process.env.SMTP_PORT ?? 587) === 465,\r\n      auth: process.env.SMTP_USER\r\n        ? {\r\n            user: process.env.SMTP_USER,\r\n            pass: process.env.SMTP_PASS,\r\n          }\r\n        : undefined,\r\n    });\r\n\r\n    const info = (await transporter.sendMail({\r\n      from: fromAddr,\r\n      to,\r\n      subject: subject ?? \"Message from SignalHub\",\r\n      text,\r\n      html,\r\n    })) as Mail;\r\n    // nodemailer returns messageId\r\n    // messageId may be like <...>\r\n    return { id: (info as any).messageId ?? null, status: \"sent\" };\r\n  }\r\n\r\n  // If no SMTP configured, throw\r\n  throw new Error(\"No email provider configured (set SMTP_HOST or RESEND_API_KEY)\");\r\n}\r\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;AAE7B;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,cAAc,IAAI;AAE1C,eAAe,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAiF;IAC9I,wFAAwF;IACxF,qCAAqC;IACrC,MAAM,WAAW,QAAQ,CAAC,WAAW,EAAE,QAAQ,GAAG,CAAC,SAAS,IAAI,sBAAsB,CAAC,CAAC;IAExF,IAAI,QAAQ,GAAG,CAAC,SAAS,EAAE;QACzB,MAAM,cAAc,wKAAU,CAAC,eAAe,CAAC;YAC7C,MAAM,QAAQ,GAAG,CAAC,SAAS;YAC3B,MAAM,OAAO,QAAQ,GAAG,CAAC,SAAS,IAAI;YACtC,QAAQ,OAAO,QAAQ,GAAG,CAAC,SAAS,IAAI,SAAS;YACjD,MAAM,QAAQ,GAAG,CAAC,SAAS,GACvB;gBACE,MAAM,QAAQ,GAAG,CAAC,SAAS;gBAC3B,MAAM,QAAQ,GAAG,CAAC,SAAS;YAC7B,IACA;QACN;QAEA,MAAM,OAAQ,MAAM,YAAY,QAAQ,CAAC;YACvC,MAAM;YACN;YACA,SAAS,WAAW;YACpB;YACA;QACF;QACA,+BAA+B;QAC/B,8BAA8B;QAC9B,OAAO;YAAE,IAAI,AAAC,KAAa,SAAS,IAAI;YAAM,QAAQ;QAAO;IAC/D;IAEA,+BAA+B;IAC/B,MAAM,IAAI,MAAM;AAClB","debugId":null}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\n// Keep legacy cookie names to support older sessions during migration.\r\n// Order matters: prefer 'session' then fallbacks.\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"] as const;\r\n\r\ntype TokenPayload = {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  // allow other claims but keep them optional/unknown\r\n  [k: string]: any;\r\n};\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n *\r\n * - Ensures a canonical `id` claim is present when provided in the payload.\r\n * - Copies `email` and `role` when present.\r\n * - Accepts `expiresIn` in jsonwebtoken format (\"7d\", \"1h\", etc).\r\n *\r\n * NOTE: Do not include sensitive data (password hashes, secrets) in token payload.\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: TokenPayload = {};\r\n\r\n  // Accept common id fallback keys for compatibility\r\n  const providedId = payload?.id ?? payload?.userId ?? payload?.sub ?? payload?.uid ?? null;\r\n  if (providedId) finalPayload.id = String(providedId);\r\n\r\n  if (payload?.email) finalPayload.email = payload.email;\r\n  if (payload?.role) finalPayload.role = payload.role;\r\n\r\n  // If you need extra claims (exp, aud, etc), add intentionally here.\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return decoded payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch (err: any) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", err?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. Returns boolean. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(\"[auth] verifyPassword error:\", err);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) OR a list of well-known cookies.\r\n * Returns the canonical user record { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (Next.js route/middleware).\r\n *\r\n * - Prefers Authorization Bearer token.\r\n * - Falls back through COOKIE_CANDIDATES (in order) and returns the first matching user.\r\n * - Accepts older tokens with sub/userId/uid claims for migration.\r\n *\r\n * Important: we fetch the user from the DB each time to ensure role and existence are canonical.\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // NextRequest cookie API: req.cookies.get(name) returns { name, value } | undefined\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie probe: ${name} => missing`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          }\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on cookie access — continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n          console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used inside route handlers.\r\n *\r\n * Example:\r\n *   const user = await requireRole(req, ['admin']);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 473, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/messages/send/route.ts"],"sourcesContent":["// frontend/src/app/api/messages/send/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport prisma from \"@/lib/prisma\";\r\nimport { sendSms, sendWhatsApp } from \"@/lib/providers/twilio\";\r\nimport { sendEmail } from \"@/lib/providers/email\";\r\n\r\n\r\n\r\nconst ALLOWED_CHANNELS = [\"SMS\", \"WHATSAPP\", \"EMAIL\", \"TWITTER\", \"MESSENGER\"] as const;\r\ntype Channel = typeof ALLOWED_CHANNELS[number];\r\n\r\nconst AUTO_CREATE_USERS = process.env.AUTO_CREATE_USERS === \"true\";\r\nconst JWT_SECRET = process.env.JWT_SECRET ?? \"dev-secret\";\r\n\r\nfunction devLog(...args: any[]) {\r\n  if (process.env.NODE_ENV !== \"production\") console.debug(\"[/api/messages/send]\", ...args);\r\n}\r\n\r\nfunction tryDecodeToken(token: string | null) {\r\n  if (!token) return null;\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    const jwt = require(\"jsonwebtoken\");\r\n    try {\r\n      return jwt.verify(token, JWT_SECRET);\r\n    } catch (verifyErr) {\r\n      devLog(\"JWT verify failed:\", verifyErr?.message ?? verifyErr);\r\n      try {\r\n        return jwt.decode(token);\r\n      } catch (decodeErr) {\r\n        devLog(\"jwt.decode failed:\", decodeErr?.message ?? decodeErr);\r\n        return null;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    devLog(\"jsonwebtoken require failed:\", e?.message ?? e);\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction extractLikelyCookieToken(cookieHeader: string | null) {\r\n  if (!cookieHeader) return null;\r\n  const names = [\r\n    \"token\",\r\n    \"next-auth.session-token\",\r\n    \"__Secure-next-auth.session-token\",\r\n    \"session\",\r\n    \"sessionToken\",\r\n  ];\r\n  for (const name of names) {\r\n    const found = cookieHeader.split(\";\").map((s) => s.trim()).find((s) => s.startsWith(`${name}=`));\r\n    if (found) {\r\n      const eq = found.indexOf(\"=\");\r\n      if (eq === -1) continue;\r\n      return decodeURIComponent(found.slice(eq + 1));\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction normalizePhone(p?: string | null) {\r\n  if (!p) return null;\r\n  const trimmed = p.trim();\r\n  return trimmed.replace(/[()\\s.-]/g, \"\");\r\n}\r\n\r\nasync function tryGetNextAuthSessionUserId() {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    const nextAuth = require(\"next-auth\");\r\n    if (nextAuth && typeof nextAuth.getServerSession === \"function\") {\r\n      try {\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        const authModule = require(\"@/lib/auth\");\r\n        const authOptions = authModule?.authOptions ?? authModule?.default ?? null;\r\n        if (authOptions) {\r\n          const session = await nextAuth.getServerSession(authOptions);\r\n          if (session?.user) {\r\n            return { id: session.user.id ?? null, email: session.user.email ?? null };\r\n          }\r\n        } else {\r\n          devLog(\"authOptions not found for next-auth in local import.\");\r\n        }\r\n      } catch (e) {\r\n        devLog(\"getServerSession attempt failed:\", e?.message ?? e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    devLog(\"next-auth not present or failed to import:\", e?.message ?? e);\r\n  }\r\n  return { id: null, email: null };\r\n}\r\n\r\n/** Append failedReason+provider to message.metadata (best-effort) */\r\nasync function appendFailedReasonToMessage(messageId: string, provider: string, reason: string) {\r\n  try {\r\n    const existing = await prisma.message.findUnique({ where: { id: messageId } });\r\n    const newMeta = { ...(existing?.metadata ?? {}), failedReason: reason, provider };\r\n    await prisma.message.update({ where: { id: messageId }, data: { metadata: newMeta as any } });\r\n  } catch (e) {\r\n    devLog(\"appendFailedReasonToMessage failed:\", e);\r\n  }\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  devLog(\"start POST\");\r\n\r\n  // parse JSON body\r\n  let body: any = null;\r\n  try {\r\n    body = await req.json();\r\n  } catch (err) {\r\n    devLog(\"invalid json body\", err);\r\n    return NextResponse.json({ error: \"Invalid JSON\" }, { status: 400 });\r\n  }\r\n\r\n  const toRaw = typeof body.to === \"string\" ? body.to.trim() : null;\r\n  const channelRaw = typeof body.channel === \"string\" ? body.channel.trim().toUpperCase() : null;\r\n  const messageBody = typeof body.body === \"string\" ? body.body.trim() : null;\r\n  const contactIdProvided = typeof body.contactId === \"string\" ? body.contactId : undefined;\r\n  const sendAtRaw = body.sendAt ? new Date(body.sendAt) : null;\r\n\r\n  if (!toRaw || !channelRaw || !messageBody) {\r\n    return NextResponse.json({ error: \"Missing required fields (to, channel, body)\" }, { status: 400 });\r\n  }\r\n\r\n  if (!ALLOWED_CHANNELS.includes(channelRaw as Channel)) {\r\n    return NextResponse.json({ error: \"Unsupported channel\" }, { status: 400 });\r\n  }\r\n  const channel = channelRaw as Channel;\r\n  const phoneNormalized = normalizePhone(toRaw);\r\n\r\n  // ---------------------------\r\n  // Resolve identity (NextAuth session -> cookie token -> Authorization Bearer)\r\n  // ---------------------------\r\n  let resolvedUserId: string | null = null;\r\n  let resolvedEmail: string | null = null;\r\n\r\n  try {\r\n    const fromNextAuth = await tryGetNextAuthSessionUserId();\r\n    resolvedUserId = fromNextAuth.id ?? resolvedUserId;\r\n    resolvedEmail = fromNextAuth.email ?? resolvedEmail;\r\n  } catch (e) {\r\n    devLog(\"next-auth helper error:\", e);\r\n  }\r\n\r\n  if (!resolvedUserId && !resolvedEmail) {\r\n    try {\r\n      const cookieHeader = req.headers.get(\"cookie\") ?? \"\";\r\n      const cookieToken = extractLikelyCookieToken(cookieHeader);\r\n      if (cookieToken) {\r\n        const decoded: any = tryDecodeToken(cookieToken);\r\n        if (decoded) {\r\n          resolvedUserId = resolvedUserId ?? (decoded.sub ?? decoded.id ?? decoded.userId ?? null);\r\n          resolvedEmail = resolvedEmail ?? (decoded.email ?? null);\r\n        }\r\n      }\r\n    } catch (e) {\r\n      devLog(\"cookie decode error:\", e);\r\n    }\r\n  }\r\n\r\n  if (!resolvedUserId && !resolvedEmail) {\r\n    try {\r\n      const authHeader = req.headers.get(\"authorization\") ?? req.headers.get(\"Authorization\");\r\n      if (authHeader && typeof authHeader === \"string\" && authHeader.startsWith(\"Bearer \")) {\r\n        const token = authHeader.slice(7).trim();\r\n        if (token) {\r\n          const decoded: any = tryDecodeToken(token);\r\n          if (decoded) {\r\n            resolvedUserId = resolvedUserId ?? (decoded.sub ?? decoded.id ?? decoded.userId ?? null);\r\n            resolvedEmail = resolvedEmail ?? (decoded.email ?? null);\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      devLog(\"authorization header decode error:\", e);\r\n    }\r\n  }\r\n\r\n  if (!resolvedUserId && !resolvedEmail) {\r\n    devLog(\"Auth failed — no user id/email resolved\");\r\n    return NextResponse.json({ error: \"Not authenticated\" }, { status: 401 });\r\n  }\r\n  devLog(\"resolved identity:\", { id: resolvedUserId ? \"<id>\" : null, email: resolvedEmail ?? null });\r\n\r\n  // ---------------------------\r\n  // Ensure sender User exists (or auto-create in dev)\r\n  // ---------------------------\r\n  let senderUser: any = null;\r\n  try {\r\n    if (resolvedUserId) senderUser = await prisma.user.findUnique({ where: { id: resolvedUserId } });\r\n    if (!senderUser && resolvedEmail) senderUser = await prisma.user.findUnique({ where: { email: resolvedEmail } });\r\n\r\n    if (!senderUser) {\r\n      if (!AUTO_CREATE_USERS) {\r\n        devLog(\"authenticated user not found in DB and AUTO_CREATE_USERS is false\");\r\n        return NextResponse.json({\r\n          error: \"Authenticated user not found in database. Please sign in or set AUTO_CREATE_USERS=true for dev.\",\r\n        }, { status: 401 });\r\n      }\r\n\r\n      const createData: any = {\r\n        email: resolvedEmail ?? `${resolvedUserId ?? \"devuser\"}@example.invalid`,\r\n        role: \"VIEWER\",\r\n        name: \"AutoCreated Dev User\",\r\n      };\r\n      if (resolvedUserId) createData.id = resolvedUserId;\r\n\r\n      try {\r\n        senderUser = await prisma.user.create({ data: createData });\r\n        devLog(\"auto-created sender user (dev):\", senderUser.id);\r\n      } catch (createErr) {\r\n        devLog(\"user.create failed (with id). Retrying without id:\", createErr?.message ?? createErr);\r\n        const fallback = { ...createData };\r\n        delete fallback.id;\r\n        senderUser = await prisma.user.create({ data: fallback });\r\n        devLog(\"auto-created sender user fallback:\", senderUser.id);\r\n      }\r\n    } else {\r\n      devLog(\"found senderUser:\", senderUser.id);\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] user ensure error:\", err);\r\n    return NextResponse.json({ error: \"Failed to resolve/create sender user\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Ensure Contact exists (lookup by id or phone) and create if missing\r\n  // ---------------------------\r\n  let contact: any = null;\r\n  try {\r\n    if (contactIdProvided) {\r\n      contact = await prisma.contact.findUnique({ where: { id: contactIdProvided } });\r\n      devLog(\"lookup contact by id:\", contactIdProvided, !!contact);\r\n    }\r\n\r\n    if (!contact && phoneNormalized) {\r\n      contact = await prisma.contact.findFirst({ where: { phone: phoneNormalized } });\r\n      devLog(\"lookup contact by phone:\", phoneNormalized, !!contact);\r\n    }\r\n\r\n    if (!contact) {\r\n      const createPayload: any = {\r\n        ...(contactIdProvided ? { id: contactIdProvided } : {}),\r\n        phone: phoneNormalized ?? undefined,\r\n      };\r\n      Object.keys(createPayload).forEach((k) => createPayload[k] === undefined && delete createPayload[k]);\r\n\r\n      contact = await prisma.contact.create({ data: createPayload });\r\n      devLog(\"created contact:\", contact?.id ?? \"(no id)\");\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] contact ensure failed:\", err);\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: \"Failed to ensure contact\",\r\n        detail: (err as any)?.message ?? String(err),\r\n        code: (err as any)?.code ?? null,\r\n      }, { status: 500 });\r\n    }\r\n    return NextResponse.json({ error: \"Failed to ensure contact\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Find or create Thread for this contact\r\n  // ---------------------------\r\n  let thread: any = null;\r\n  try {\r\n    thread = await prisma.thread.findFirst({\r\n      where: { contactId: contact.id },\r\n      orderBy: { lastAt: \"desc\" as const },\r\n    });\r\n\r\n    if (!thread) {\r\n      thread = await prisma.thread.create({\r\n        data: {\r\n          contactId: contact.id,\r\n          creatorId: senderUser?.id ?? undefined,\r\n          lastAt: new Date(),\r\n        } as any,\r\n      });\r\n      devLog(\"created thread:\", thread.id);\r\n    } else {\r\n      devLog(\"found thread:\", thread.id);\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] thread ensure failed:\", err);\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: \"Failed to ensure thread\",\r\n        detail: (err as any)?.message ?? String(err),\r\n        code: (err as any)?.code ?? null,\r\n      }, { status: 500 });\r\n    }\r\n    return NextResponse.json({ error: \"Failed to ensure thread\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Scheduled messages — create ScheduledMessage and return early\r\n  // ---------------------------\r\n  if (sendAtRaw && !Number.isNaN(sendAtRaw.getTime())) {\r\n    try {\r\n      const scheduled = await prisma.scheduledMessage.create({\r\n        data: {\r\n          threadId: thread.id,\r\n          senderId: senderUser?.id ?? undefined,\r\n          body: messageBody,\r\n          channel,\r\n          sendAt: sendAtRaw,\r\n          metadata: { to: phoneNormalized, ...(body.metadata ?? {}) },\r\n        },\r\n      });\r\n      devLog(\"created scheduledMessage:\", scheduled.id);\r\n      return NextResponse.json({ ok: true, scheduled, thread, notice: \"Message scheduled for future delivery.\" });\r\n    } catch (err: any) {\r\n      console.error(\"[/api/messages/send] failed creating scheduled message:\", err);\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: \"Failed to schedule message\",\r\n        detail: process.env.NODE_ENV !== \"production\" ? (err?.message ?? String(err)) : undefined,\r\n      }, { status: 500 });\r\n    }\r\n  }\r\n\r\n  // ---------------------------\r\n  // Create the outbound Message (do NOT set `status` on Message)\r\n  // ---------------------------\r\n  let createdMessage: any = null;\r\n  try {\r\n    const messageData: any = {\r\n      threadId: thread.id,\r\n      senderId: senderUser?.id ?? null,\r\n      body: messageBody,\r\n      channel,\r\n      direction: \"OUTBOUND\",\r\n      metadata: { to: phoneNormalized, ...(body.metadata ?? {}) },\r\n      // Note: Message model doesn't have `status` in your schema. Use externalId / sentAt / deliveredAt.\r\n    };\r\n\r\n    createdMessage = await prisma.message.create({ data: messageData });\r\n    devLog(\"created message:\", createdMessage.id);\r\n\r\n    // best-effort update thread.lastAt\r\n    try {\r\n      await prisma.thread.update({ where: { id: thread.id }, data: { lastAt: new Date() } });\r\n    } catch (updateErr) {\r\n      devLog(\"failed to update thread.lastAt:\", updateErr?.message ?? updateErr);\r\n    }\r\n  } catch (err: any) {\r\n    console.error(\"[/api/messages/send] error creating message (full):\", err);\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: err?.message ?? String(err),\r\n        code: err?.code ?? null,\r\n        meta: err?.meta ?? null,\r\n      }, { status: 500 });\r\n    }\r\n    return NextResponse.json({ ok: false, error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Immediate delivery for supported channels (graceful fallback if provider not configured)\r\n  // ---------------------------\r\n  try {\r\n    if (channel === \"SMS\") {\r\n      devLog(\"sending SMS via provider...\", { to: createdMessage.metadata?.to ?? toRaw });\r\n      try {\r\n        const res = await sendSms({ to: createdMessage.metadata?.to ?? toRaw, body: messageBody });\r\n        await prisma.message.update({\r\n          where: { id: createdMessage.id },\r\n          data: {\r\n            externalId: (res as any)?.sid ?? (res as any)?.id ?? null,\r\n            sentAt: new Date(),\r\n          },\r\n        });\r\n      } catch (providerErr: any) {\r\n        devLog(\"provider send failed (SMS):\", providerErr?.message ?? providerErr);\r\n        await appendFailedReasonToMessage(createdMessage.id, \"twilio\", providerErr?.message ?? String(providerErr));\r\n        const message = await prisma.message.findUnique({ where: { id: createdMessage.id } });\r\n        return NextResponse.json({\r\n          ok: true,\r\n          message,\r\n          thread,\r\n          notice: \"Message saved but Twilio SMS send failed (provider not configured or error). Delivery pending.\",\r\n          debug: process.env.NODE_ENV !== \"production\" ? { providerError: providerErr?.message ?? String(providerErr) } : undefined,\r\n        });\r\n      }\r\n    } else if (channel === \"WHATSAPP\") {\r\n      devLog(\"sending WhatsApp via provider...\", { to: createdMessage.metadata?.to ?? toRaw });\r\n      try {\r\n        const res = await sendWhatsApp({ to: createdMessage.metadata?.to ?? toRaw, body: messageBody });\r\n        await prisma.message.update({\r\n          where: { id: createdMessage.id },\r\n          data: {\r\n            externalId: (res as any)?.sid ?? (res as any)?.id ?? null,\r\n            sentAt: new Date(),\r\n          },\r\n        });\r\n      } catch (providerErr: any) {\r\n        devLog(\"provider send failed (WHATSAPP):\", providerErr?.message ?? providerErr);\r\n        await appendFailedReasonToMessage(createdMessage.id, \"twilio_whatsapp\", providerErr?.message ?? String(providerErr));\r\n        const message = await prisma.message.findUnique({ where: { id: createdMessage.id } });\r\n        return NextResponse.json({\r\n          ok: true,\r\n          message,\r\n          thread,\r\n          notice: \"Message saved but Twilio WhatsApp send failed (provider not configured or error). Delivery pending.\",\r\n          debug: process.env.NODE_ENV !== \"production\" ? { providerError: providerErr?.message ?? String(providerErr) } : undefined,\r\n        });\r\n      }\r\n    } else if (channel === \"EMAIL\") {\r\n      devLog(\"sending EMAIL via provider...\", { to: createdMessage.metadata?.to ?? toRaw });\r\n      try {\r\n        const emailRes = await sendEmail({\r\n          to: createdMessage.metadata?.to ?? toRaw,\r\n          subject: body.subject ?? \"Message from SignalHub\",\r\n          html: body.html ?? `<div>${messageBody}</div>`,\r\n          text: body.text ?? messageBody,\r\n          from: body.from ?? undefined,\r\n        });\r\n        await prisma.message.update({\r\n          where: { id: createdMessage.id },\r\n          data: {\r\n            externalId: (emailRes as any)?.id ?? (emailRes as any)?.messageId ?? null,\r\n            sentAt: new Date(),\r\n          },\r\n        });\r\n      } catch (providerErr: any) {\r\n        devLog(\"provider send failed (EMAIL):\", providerErr?.message ?? providerErr);\r\n        await appendFailedReasonToMessage(createdMessage.id, \"email\", providerErr?.message ?? String(providerErr));\r\n        const message = await prisma.message.findUnique({ where: { id: createdMessage.id } });\r\n        return NextResponse.json({\r\n          ok: true,\r\n          message,\r\n          thread,\r\n          notice: \"Message saved but email send failed (provider not configured or error). Delivery pending.\",\r\n          debug: process.env.NODE_ENV !== \"production\" ? { providerError: providerErr?.message ?? String(providerErr) } : undefined,\r\n        });\r\n      }\r\n    } else {\r\n      // TWITTER / MESSENGER: not integrated yet — keep message in DB for later processing\r\n      devLog(`channel ${channel} not integrated for immediate delivery; message left in DB for later processing.`);\r\n      const message = await prisma.message.findUnique({ where: { id: createdMessage.id } });\r\n      return NextResponse.json({\r\n        ok: true,\r\n        message,\r\n        thread,\r\n        notice: `Channel ${channel} is not integrated for immediate delivery. Message stored.`,\r\n      });\r\n    }\r\n  } catch (fatalErr: any) {\r\n    // Defensive catch - provider-level errors should have been handled above\r\n    console.error(\"[/api/messages/send] unexpected fatal error during provider send:\", fatalErr);\r\n    await appendFailedReasonToMessage(createdMessage.id, \"internal\", fatalErr?.message ?? String(fatalErr));\r\n    const message = await prisma.message.findUnique({ where: { id: createdMessage.id } });\r\n    return NextResponse.json({\r\n      ok: true,\r\n      message,\r\n      thread,\r\n      notice: \"Message saved but delivery failed due to an internal error. Check server logs.\",\r\n      debug: process.env.NODE_ENV !== \"production\" ? { error: String(fatalErr) } : undefined,\r\n    });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Re-fetch and return the updated message\r\n  // ---------------------------\r\n  const message = await prisma.message.findUnique({ where: { id: createdMessage.id } });\r\n  return NextResponse.json({ ok: true, message, thread });\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}