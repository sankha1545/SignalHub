{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/messages/send/route.ts"],"sourcesContent":["// app/api/messages/send/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n// helper to safely parse JSON body\r\n// add near top of file for debugging\r\nconsole.log(\"[/api/messages/send] incoming request\");\r\ntry {\r\n  // If using Request from Next.js App Router:\r\n  // print raw cookie header\r\n  // (if you have access to the Node request object instead, print req.headers.cookie)\r\n  // but in Next.js route.ts you can read headers via Request.headers\r\n  // example: headers().get('cookie') is server-only import from 'next/headers' if needed\r\n  // For simplicity (works in many setups):\r\n  const cookieHeader = (globalThis as any).__NEXT_INIT__ ? null : null;\r\n  console.log(\"[/api/messages/send] headers placeholder - adapt to your runtime\");\r\n} catch (e) {\r\n  console.warn(\"[/api/messages/send] debug header read failed\", e);\r\n}\r\n\r\nasync function parseJson(req: Request) {\r\n  try {\r\n    return await req.json();\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await parseJson(req);\r\n    const to: string | undefined = body?.to;\r\n    const channel: string | undefined = body?.channel;\r\n    const textBody: string | undefined = body?.body;\r\n    const threadId: string | undefined = body?.threadId;\r\n    const contactId: string | undefined = body?.contactId;\r\n    const metadata = body?.metadata ?? {};\r\n\r\n    if (!to || !channel || !textBody) {\r\n      return NextResponse.json({ error: \"Missing required fields: to, channel, body\" }, { status: 400 });\r\n    }\r\n\r\n    // Obtain authenticated user id here. Replace with your auth logic.\r\n    // Example: const userId = await getUserIdFromReq(req);\r\n    const userId = (req as any).userId ?? process.env.DEBUG_FAKE_USER_ID ?? null;\r\n    if (!userId) {\r\n      return NextResponse.json({ error: \"Not authenticated\" }, { status: 401 });\r\n    }\r\n\r\n    // Ensure channel upper-case\r\n    const channelUC = String(channel).toUpperCase();\r\n\r\n    // Find or create thread safely\r\n    let thread: any | null = null;\r\n    try {\r\n      if (threadId) {\r\n        thread = await prisma.thread.findUnique({ where: { id: threadId } });\r\n      }\r\n      if (!thread && contactId) {\r\n        thread = await prisma.thread.findFirst({ where: { contactId } });\r\n        if (!thread) {\r\n          thread = await prisma.thread.create({\r\n            data: {\r\n              contactId,\r\n              // set minimal fields â€” adapt to your Thread model\r\n              title: `Thread for contact ${contactId}`,\r\n              metadata: { createdBy: userId, to },\r\n            } as any,\r\n          });\r\n        }\r\n      }\r\n      if (!thread) {\r\n        // try to find thread by metadata 'to' if thread stores metadata JSON\r\n        try {\r\n          thread = await prisma.thread.findFirst({\r\n            where: { metadata: { path: [\"to\"], equals: to } as any }, // may need adjustment for your DB connector\r\n          });\r\n        } catch {\r\n          // If JSON query unsupported, ignore and fallback to create\r\n          thread = null;\r\n        }\r\n      }\r\n      if (!thread) {\r\n        // fallback create minimal thread\r\n        thread = await prisma.thread.create({\r\n          data: {\r\n            title: `Thread with ${to}`,\r\n            metadata: { to, createdBy: userId },\r\n          } as any,\r\n        });\r\n      }\r\n    } catch (errThread) {\r\n      console.error(\"[send] thread lookup/create failed:\", errThread);\r\n      // return explanatory error to client\r\n      return NextResponse.json({ error: \"Failed to prepare thread\", detail: String(errThread) }, { status: 500 });\r\n    }\r\n\r\n    // Create message and connect to thread (use relation connect to satisfy schemas that require relation)\r\n    let message;\r\n    try {\r\n      message = await prisma.message.create({\r\n        data: {\r\n          thread: { connect: { id: thread.id } },\r\n          senderId: userId,\r\n          body: textBody,\r\n          channel: channelUC,\r\n          direction: \"OUTBOUND\",\r\n          metadata: { ...metadata, to },\r\n          // add other required fields according to your schema\r\n        } as any,\r\n      });\r\n\r\n      // update thread metadata/lastAt snippet\r\n      await prisma.thread.update({\r\n        where: { id: thread.id },\r\n        data: {\r\n          lastAt: new Date(),\r\n          // optionally update snippet or unread counts\r\n        } as any,\r\n      });\r\n    } catch (prismaErr) {\r\n      console.error(\"[send] prisma message.create failed:\", prismaErr);\r\n      // return helpful JSON to client\r\n      return NextResponse.json({ error: \"Failed to create message\", detail: String(prismaErr) }, { status: 500 });\r\n    }\r\n\r\n    // fetch fresh canonical thread for client\r\n    const freshThread = await prisma.thread.findUnique({\r\n      where: { id: thread.id },\r\n      include: { messages: { take: 20, orderBy: { createdAt: \"desc\" } } }, // adapt include shape\r\n    });\r\n\r\n    return NextResponse.json({ ok: true, message, thread: freshThread });\r\n  } catch (err) {\r\n    console.error(\"[send] unexpected error:\", err);\r\n    return NextResponse.json({ error: \"Internal server error\", detail: String(err) }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}