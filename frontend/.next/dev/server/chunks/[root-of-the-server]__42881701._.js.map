{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\n// Keep legacy cookie names to support older sessions during migration.\r\n// Order matters: prefer 'session' then fallbacks.\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"] as const;\r\n\r\ntype TokenPayload = {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  // allow other claims but keep them optional/unknown\r\n  [k: string]: any;\r\n};\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n *\r\n * - Ensures a canonical `id` claim is present when provided in the payload.\r\n * - Copies `email` and `role` when present.\r\n * - Accepts `expiresIn` in jsonwebtoken format (\"7d\", \"1h\", etc).\r\n *\r\n * NOTE: Do not include sensitive data (password hashes, secrets) in token payload.\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: TokenPayload = {};\r\n\r\n  // Accept common id fallback keys for compatibility\r\n  const providedId = payload?.id ?? payload?.userId ?? payload?.sub ?? payload?.uid ?? null;\r\n  if (providedId) finalPayload.id = String(providedId);\r\n\r\n  if (payload?.email) finalPayload.email = payload.email;\r\n  if (payload?.role) finalPayload.role = payload.role;\r\n\r\n  // If you need extra claims (exp, aud, etc), add intentionally here.\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return decoded payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch (err: any) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", err?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. Returns boolean. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(\"[auth] verifyPassword error:\", err);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) OR a list of well-known cookies.\r\n * Returns the canonical user record { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (Next.js route/middleware).\r\n *\r\n * - Prefers Authorization Bearer token.\r\n * - Falls back through COOKIE_CANDIDATES (in order) and returns the first matching user.\r\n * - Accepts older tokens with sub/userId/uid claims for migration.\r\n *\r\n * Important: we fetch the user from the DB each time to ensure role and existence are canonical.\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // NextRequest cookie API: req.cookies.get(name) returns { name, value } | undefined\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie probe: ${name} => missing`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          }\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on cookie access — continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n          console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used inside route handlers.\r\n *\r\n * Example:\r\n *   const user = await requireRole(req, ['admin']);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;;;;;;;;;;;;AAClB;AACA;AACA;;;;AAGA,MAAM,aACJ,QAAQ,GAAG,CAAC,cAAc,IAC1B,QAAQ,GAAG,CAAC,eAAe,IAC3B,QAAQ,GAAG,CAAC,UAAU,IACtB;AAEF,uEAAuE;AACvE,kDAAkD;AAClD,MAAM,oBAAoB;IAAC;IAAW;IAAS;IAAc;IAAa;CAAO;AAmB1E,SAAS,UAAU,OAA4B,EAAE,YAAY,IAAI;IACtE,MAAM,eAA6B,CAAC;IAEpC,mDAAmD;IACnD,MAAM,aAAa,SAAS,MAAM,SAAS,UAAU,SAAS,OAAO,SAAS,OAAO;IACrF,IAAI,YAAY,aAAa,EAAE,GAAG,OAAO;IAEzC,IAAI,SAAS,OAAO,aAAa,KAAK,GAAG,QAAQ,KAAK;IACtD,IAAI,SAAS,MAAM,aAAa,IAAI,GAAG,QAAQ,IAAI;IAEnD,oEAAoE;IACpE,OAAO,8JAAG,CAAC,IAAI,CAAC,cAAc,YAAY;QAAE;IAAU;AACxD;AAGO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,UAAU,8JAAG,CAAC,MAAM,CAAC,OAAO;QAClC,OAAO;IACT,EAAE,OAAO,KAAU;QACjB,wCAA2C;YACzC,QAAQ,KAAK,CAAC,8BAA8B,KAAK,WAAW;QAC9D;QACA,OAAO;IACT;AACF;AAKO,eAAe,aAAa,QAAgB;IACjD,MAAM,aAAa,OAAO,QAAQ,GAAG,CAAC,kBAAkB,IAAI;IAC5D,OAAO,gHAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAGO,eAAe,eAAe,QAAgB,EAAE,IAAY;IACjE,IAAI;QACF,OAAO,gHAAM,CAAC,OAAO,CAAC,UAAU;IAClC,EAAE,OAAO,KAAK;QACZ,wCAA2C;YACzC,QAAQ,KAAK,CAAC,gCAAgC;QAChD;QACA,OAAO;IACT;AACF;AAgBO,eAAe,mBAAmB,GAAgB;IACvD,IAAI;QACF,mCAAmC;QACnC,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,YAAY,WAAW,YAAY;YACrC,MAAM,QAAQ,WAAW,KAAK,CAAC,GAAG,IAAI;YACtC,MAAM,UAAU,YAAY;YAC5B,IAAI,SAAS;gBACX,MAAM,SAAS,QAAQ,EAAE,IAAI,QAAQ,GAAG,IAAI,QAAQ,MAAM,IAAI,QAAQ,GAAG;gBACzE,IAAI,QAAQ;oBACV,MAAM,OAAO,MAAM,4IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;wBACxC,OAAO;4BAAE,IAAI,OAAO;wBAAQ;wBAC5B,QAAQ;4BAAE,IAAI;4BAAM,OAAO;4BAAM,MAAM;4BAAM,MAAM;wBAAK;oBAC1D;oBACA,IAAI,MAAM,OAAO;gBACnB;YACF,OAAO,wCAA2C;gBAChD,QAAQ,KAAK,CAAC;YAChB;QACF;QAEA,aAAa;QACb,oFAAoF;QACpF,KAAK,MAAM,QAAQ,kBAAmB;YACpC,IAAI;gBACF,MAAM,SAAS,IAAI,OAAO,CAAC,GAAG,CAAC;gBAC/B,IAAI,CAAC,QAAQ;oBACX,wCAA2C;wBACzC,QAAQ,KAAK,CAAC,CAAC,qBAAqB,EAAE,KAAK,WAAW,CAAC;oBACzD;oBACA;gBACF;gBAEA,MAAM,QAAQ,OAAO,KAAK;gBAC1B,IAAI,CAAC,OAAO;gBAEZ,MAAM,UAAU,YAAY;gBAC5B,IAAI,CAAC,SAAS;oBACZ,wCAA2C;wBACzC,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,4BAA4B,CAAC;oBACnE;oBACA;gBACF;gBAEA,MAAM,SAAS,QAAQ,EAAE,IAAI,QAAQ,GAAG,IAAI,QAAQ,MAAM,IAAI,QAAQ,GAAG;gBACzE,IAAI,CAAC,QAAQ;oBACX,wCAA2C;wBACzC,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,gCAAgC,CAAC;oBACvE;oBACA;gBACF;gBAEA,MAAM,OAAO,MAAM,4IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE,IAAI,OAAO;oBAAQ;oBAC5B,QAAQ;wBAAE,IAAI;wBAAM,OAAO;wBAAM,MAAM;wBAAM,MAAM;oBAAK;gBAC1D;gBAEA,IAAI,MAAM;oBACR,wCAA2C;wBACzC,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,iBAAiB,EAAE,KAAK,EAAE,EAAE;oBAClE;oBACA,OAAO;gBACT,OAAO;oBACL,wCAA2C;wBACzC,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,YAAY,EAAE,OAAO,UAAU,CAAC;oBACtE;gBACF;YACF,EAAE,OAAO,KAAK;gBACZ,wEAAwE;gBACxE,wCAA2C;oBACzC,QAAQ,KAAK,CAAC,CAAC,8BAA8B,EAAE,KAAK,CAAC,CAAC,EAAE;gBAC1D;gBACA;YACF;QACF;QAEA,kBAAkB;QAClB,OAAO;IACT,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO;IACT;AACF;AASO,eAAe,YAAY,GAAgB,EAAE,eAAyB,EAAE;IAC7E,MAAM,OAAO,MAAM,mBAAmB;IACtC,IAAI,CAAC,MAAM,MAAM,IAAI,SAAS,gBAAgB;QAAE,QAAQ;IAAI;IAC5D,IAAI,aAAa,MAAM,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;QAC5D,MAAM,IAAI,SAAS,aAAa;YAAE,QAAQ;QAAI;IAChD;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/messages/send/route.ts"],"sourcesContent":["// frontend/src/app/api/messages/send/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n/**\r\n * Message send route (matches schema.prisma models)\r\n *\r\n * Behavior:\r\n *  - Resolve user from NextAuth session, then cookie token, then Authorization header.\r\n *  - If resolved user record exists, use it. If missing, behavior controlled by AUTO_CREATE_USERS:\r\n *      - AUTO_CREATE_USERS=true  -> auto-create a minimal user (dev convenience)\r\n *      - otherwise -> return 401 (auth mismatch)\r\n *  - Ensure Contact exists (lookup by id or normalized phone; create minimal if missing).\r\n *  - Find or create Thread for that contact (creatorId set only if user exists).\r\n *  - Create Message using scalar `threadId` and `senderId`.\r\n *\r\n * Notes:\r\n *  - Designed to be robust in development. Do NOT enable AUTO_CREATE_USERS in production unless you understand the implications.\r\n *  - This file intentionally returns extra error details in non-production to help debugging.\r\n */\r\n\r\n// --------------------------- Helpers & config ---------------------------\r\nconst ALLOWED_CHANNELS = [\"SMS\", \"WHATSAPP\", \"EMAIL\", \"TWITTER\", \"MESSENGER\"] as const;\r\ntype Channel = typeof ALLOWED_CHANNELS[number];\r\n\r\nconst AUTO_CREATE_USERS = process.env.AUTO_CREATE_USERS === \"true\"; // set true for dev autoprov behavior\r\n\r\nfunction devLog(...args: any[]) {\r\n  if (process.env.NODE_ENV !== \"production\") console.debug(\"[/api/messages/send]\", ...args);\r\n}\r\n\r\n// JWT helpers (verify then decode fallback)\r\nconst JWT_SECRET = process.env.JWT_SECRET ?? \"dev-secret\";\r\nfunction tryDecodeToken(token: string | null) {\r\n  if (!token) return null;\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    const jwt = require(\"jsonwebtoken\");\r\n    try {\r\n      return jwt.verify(token, JWT_SECRET);\r\n    } catch (verifyErr) {\r\n      devLog(\"JWT verify failed:\", verifyErr?.message ?? verifyErr);\r\n      try {\r\n        return jwt.decode(token);\r\n      } catch (decodeErr) {\r\n        devLog(\"jwt.decode failed:\", decodeErr?.message ?? decodeErr);\r\n        return null;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    devLog(\"jsonwebtoken require failed:\", e?.message ?? e);\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction extractLikelyCookieToken(cookieHeader: string | null) {\r\n  if (!cookieHeader) return null;\r\n  const names = [\r\n    \"token\",\r\n    \"next-auth.session-token\",\r\n    \"__Secure-next-auth.session-token\",\r\n    \"session\",\r\n    \"sessionToken\",\r\n  ];\r\n  for (const name of names) {\r\n    const found = cookieHeader.split(\";\").map(s => s.trim()).find(s => s.startsWith(`${name}=`));\r\n    if (found) {\r\n      const eq = found.indexOf(\"=\");\r\n      if (eq === -1) continue;\r\n      return decodeURIComponent(found.slice(eq + 1));\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction normalizePhone(p?: string | null) {\r\n  if (!p) return null;\r\n  // simple normalizer — keep leading plus if present\r\n  const trimmed = p.trim();\r\n  return trimmed.replace(/[()\\s.-]/g, \"\");\r\n}\r\n\r\nasync function tryGetNextAuthSessionUserId() {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    const nextAuth = require(\"next-auth\");\r\n    if (nextAuth && typeof nextAuth.getServerSession === \"function\") {\r\n      try {\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        const authModule = require(\"@/lib/auth\");\r\n        const authOptions = authModule?.authOptions ?? authModule?.default ?? null;\r\n        if (authOptions) {\r\n          const session = await nextAuth.getServerSession(authOptions);\r\n          if (session?.user) {\r\n            return { id: session.user.id ?? null, email: session.user.email ?? null };\r\n          }\r\n        } else {\r\n          devLog(\"authOptions not found for next-auth in local import.\");\r\n        }\r\n      } catch (e) {\r\n        devLog(\"getServerSession attempt failed:\", e?.message ?? e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    devLog(\"next-auth not present or failed to import:\", e?.message ?? e);\r\n  }\r\n  return { id: null, email: null };\r\n}\r\n\r\n// --------------------------- Route handler ---------------------------\r\nexport async function POST(req: Request) {\r\n  devLog(\"start POST\");\r\n\r\n  // parse body safely\r\n  let body: any = null;\r\n  try {\r\n    body = await req.json();\r\n  } catch (err) {\r\n    devLog(\"invalid json body\", err);\r\n    return NextResponse.json({ error: \"Invalid JSON\" }, { status: 400 });\r\n  }\r\n\r\n  const toRaw = typeof body.to === \"string\" ? body.to.trim() : null;\r\n  const channelRaw = typeof body.channel === \"string\" ? body.channel.trim().toUpperCase() : null;\r\n  const messageBody = typeof body.body === \"string\" ? body.body.trim() : null;\r\n  const contactIdProvided = typeof body.contactId === \"string\" ? body.contactId : undefined;\r\n\r\n  if (!toRaw || !channelRaw || !messageBody) {\r\n    return NextResponse.json({ error: \"Missing required fields (to, channel, body)\" }, { status: 400 });\r\n  }\r\n\r\n  if (!ALLOWED_CHANNELS.includes(channelRaw as Channel)) {\r\n    return NextResponse.json({ error: \"Unsupported channel\" }, { status: 400 });\r\n  }\r\n  const channel = channelRaw as Channel;\r\n  const phoneNormalized = normalizePhone(toRaw);\r\n\r\n  // ---------------------------\r\n  // Resolve identity (NextAuth session -> cookie token -> Authorization Bearer)\r\n  // ---------------------------\r\n  let resolvedUserId: string | null = null;\r\n  let resolvedEmail: string | null = null;\r\n  try {\r\n    const fromNextAuth = await tryGetNextAuthSessionUserId();\r\n    resolvedUserId = fromNextAuth.id ?? resolvedUserId;\r\n    resolvedEmail = fromNextAuth.email ?? resolvedEmail;\r\n  } catch (e) {\r\n    devLog(\"next-auth helper error:\", e);\r\n  }\r\n\r\n  if (!resolvedUserId && !resolvedEmail) {\r\n    try {\r\n      const cookieHeader = req.headers.get(\"cookie\") ?? \"\";\r\n      const cookieToken = extractLikelyCookieToken(cookieHeader);\r\n      if (cookieToken) {\r\n        const decoded: any = tryDecodeToken(cookieToken);\r\n        if (decoded) {\r\n          resolvedUserId = resolvedUserId ?? (decoded.sub ?? decoded.id ?? decoded.userId ?? null);\r\n          resolvedEmail = resolvedEmail ?? (decoded.email ?? null);\r\n        }\r\n      }\r\n    } catch (e) {\r\n      devLog(\"cookie decode error:\", e);\r\n    }\r\n  }\r\n\r\n  // Authorization header fallback (Bearer)\r\n  if (!resolvedUserId && !resolvedEmail) {\r\n    try {\r\n      const authHeader = req.headers.get(\"authorization\") ?? req.headers.get(\"Authorization\");\r\n      if (authHeader && typeof authHeader === \"string\" && authHeader.startsWith(\"Bearer \")) {\r\n        const token = authHeader.slice(7).trim();\r\n        if (token) {\r\n          const decoded: any = tryDecodeToken(token);\r\n          if (decoded) {\r\n            resolvedUserId = resolvedUserId ?? (decoded.sub ?? decoded.id ?? decoded.userId ?? null);\r\n            resolvedEmail = resolvedEmail ?? (decoded.email ?? null);\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      devLog(\"authorization header decode error:\", e);\r\n    }\r\n  }\r\n\r\n  if (!resolvedUserId && !resolvedEmail) {\r\n    devLog(\"Auth failed — no user id/email resolved\");\r\n    return NextResponse.json({ error: \"Not authenticated\" }, { status: 401 });\r\n  }\r\n  devLog(\"resolved identity:\", { id: resolvedUserId ? \"<id>\" : null, email: resolvedEmail ?? null });\r\n\r\n  // ---------------------------\r\n  // Ensure sender User exists (or auto-create in dev)\r\n  // ---------------------------\r\n  let senderUser: any = null;\r\n  try {\r\n    if (resolvedUserId) senderUser = await prisma.user.findUnique({ where: { id: resolvedUserId } });\r\n    if (!senderUser && resolvedEmail) senderUser = await prisma.user.findUnique({ where: { email: resolvedEmail } });\r\n\r\n    if (!senderUser) {\r\n      if (!AUTO_CREATE_USERS) {\r\n        devLog(\"authenticated user not found in DB and AUTO_CREATE_USERS is false\");\r\n        return NextResponse.json({\r\n          error: \"Authenticated user not found in database. Please sign in or set AUTO_CREATE_USERS=true for dev.\",\r\n        }, { status: 401 });\r\n      }\r\n\r\n      // Create minimal user for dev convenience. Keep fields minimal to avoid unique violations.\r\n      const createData: any = {\r\n        email: resolvedEmail ?? `${resolvedUserId ?? \"devuser\"}@example.invalid`,\r\n        role: \"VIEWER\",\r\n        name: \"AutoCreated Dev User\",\r\n      };\r\n      if (resolvedUserId) createData.id = resolvedUserId;\r\n\r\n      try {\r\n        senderUser = await prisma.user.create({ data: createData });\r\n        devLog(\"auto-created sender user (dev):\", senderUser.id);\r\n      } catch (createErr) {\r\n        // If setting id failed (rare), retry without id\r\n        devLog(\"user.create failed (with id). Retrying without id:\", createErr?.message ?? createErr);\r\n        const fallback = { ...createData };\r\n        delete fallback.id;\r\n        senderUser = await prisma.user.create({ data: fallback });\r\n        devLog(\"auto-created sender user fallback:\", senderUser.id);\r\n      }\r\n    } else {\r\n      devLog(\"found senderUser:\", senderUser.id);\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] user ensure error:\", err);\r\n    return NextResponse.json({ error: \"Failed to resolve/create sender user\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Ensure Contact exists (lookup by id or phone) and create if missing\r\n  // ---------------------------\r\n  let contact: any = null;\r\n  try {\r\n    if (contactIdProvided) {\r\n      contact = await prisma.contact.findUnique({ where: { id: contactIdProvided } });\r\n      devLog(\"lookup contact by id:\", contactIdProvided, !!contact);\r\n    }\r\n\r\n    if (!contact && phoneNormalized) {\r\n      contact = await prisma.contact.findFirst({ where: { phone: phoneNormalized } });\r\n      devLog(\"lookup contact by phone:\", phoneNormalized, !!contact);\r\n    }\r\n\r\n    if (!contact) {\r\n      const createPayload: any = {\r\n        ...(contactIdProvided ? { id: contactIdProvided } : {}),\r\n        phone: phoneNormalized ?? undefined,\r\n      };\r\n      // drop undefined keys\r\n      Object.keys(createPayload).forEach((k) => createPayload[k] === undefined && delete createPayload[k]);\r\n\r\n      contact = await prisma.contact.create({ data: createPayload });\r\n      devLog(\"created contact:\", contact?.id ?? \"(no id)\");\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] contact ensure failed:\", err);\r\n    // If unique constraint fails (rare), give specific info in dev\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: \"Failed to ensure contact\",\r\n        detail: (err as any)?.message ?? String(err),\r\n        code: (err as any)?.code ?? null,\r\n      }, { status: 500 });\r\n    }\r\n    return NextResponse.json({ error: \"Failed to ensure contact\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Find or create Thread for this contact\r\n  // ---------------------------\r\n  let thread: any = null;\r\n  try {\r\n    thread = await prisma.thread.findFirst({\r\n      where: { contactId: contact.id },\r\n      orderBy: { lastAt: \"desc\" },\r\n    });\r\n\r\n    if (!thread) {\r\n      thread = await prisma.thread.create({\r\n        data: {\r\n          contactId: contact.id,\r\n          // schema allows creatorId to be nullable; set because senderUser exists\r\n          creatorId: senderUser?.id ?? undefined,\r\n          lastAt: new Date(),\r\n        } as any,\r\n      });\r\n      devLog(\"created thread:\", thread.id);\r\n    } else {\r\n      devLog(\"found thread:\", thread.id);\r\n    }\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] thread ensure failed:\", err);\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: \"Failed to ensure thread\",\r\n        detail: (err as any)?.message ?? String(err),\r\n        code: (err as any)?.code ?? null,\r\n      }, { status: 500 });\r\n    }\r\n    return NextResponse.json({ error: \"Failed to ensure thread\" }, { status: 500 });\r\n  }\r\n\r\n  // ---------------------------\r\n  // Create the message (use scalar senderId)\r\n  // ---------------------------\r\n  try {\r\n    const messageData: any = {\r\n      threadId: thread.id,\r\n      senderId: senderUser?.id ?? null, // Message.senderId is nullable in schema; use null only if senderUser is missing (shouldn't be)\r\n      body: messageBody,\r\n      channel,\r\n      direction: \"OUTBOUND\",\r\n      metadata: { to: phoneNormalized },\r\n    };\r\n\r\n    const message = await prisma.message.create({ data: messageData });\r\n    devLog(\"created message:\", message.id);\r\n\r\n    // update thread.lastAt (best-effort)\r\n    try {\r\n      await prisma.thread.update({\r\n        where: { id: thread.id },\r\n        data: { lastAt: new Date() },\r\n      });\r\n    } catch (updateErr) {\r\n      devLog(\"failed to update thread.lastAt:\", updateErr?.message ?? updateErr);\r\n    }\r\n\r\n    return NextResponse.json({ ok: true, message, thread });\r\n  } catch (err: any) {\r\n    console.error(\"[/api/messages/send] error creating message (full):\", err);\r\n\r\n    // return helpful error in development\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      return NextResponse.json({\r\n        ok: false,\r\n        error: err?.message ?? String(err),\r\n        code: err?.code ?? null,\r\n        meta: err?.meta ?? null,\r\n      }, { status: 500 });\r\n    }\r\n\r\n    return NextResponse.json({ ok: false, error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}