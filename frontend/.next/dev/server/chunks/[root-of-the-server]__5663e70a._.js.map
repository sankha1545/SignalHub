{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\n// Keep legacy cookie names to support older sessions during migration.\r\n// Order matters: prefer 'session' then fallbacks.\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"] as const;\r\n\r\ntype TokenPayload = {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  // allow other claims but keep them optional/unknown\r\n  [k: string]: any;\r\n};\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n *\r\n * - Ensures a canonical `id` claim is present when provided in the payload.\r\n * - Copies `email` and `role` when present.\r\n * - Accepts `expiresIn` in jsonwebtoken format (\"7d\", \"1h\", etc).\r\n *\r\n * NOTE: Do not include sensitive data (password hashes, secrets) in token payload.\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: TokenPayload = {};\r\n\r\n  // Accept common id fallback keys for compatibility\r\n  const providedId = payload?.id ?? payload?.userId ?? payload?.sub ?? payload?.uid ?? null;\r\n  if (providedId) finalPayload.id = String(providedId);\r\n\r\n  if (payload?.email) finalPayload.email = payload.email;\r\n  if (payload?.role) finalPayload.role = payload.role;\r\n\r\n  // If you need extra claims (exp, aud, etc), add intentionally here.\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return decoded payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch (err: any) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", err?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. Returns boolean. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(\"[auth] verifyPassword error:\", err);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) OR a list of well-known cookies.\r\n * Returns the canonical user record { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (Next.js route/middleware).\r\n *\r\n * - Prefers Authorization Bearer token.\r\n * - Falls back through COOKIE_CANDIDATES (in order) and returns the first matching user.\r\n * - Accepts older tokens with sub/userId/uid claims for migration.\r\n *\r\n * Important: we fetch the user from the DB each time to ensure role and existence are canonical.\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // NextRequest cookie API: req.cookies.get(name) returns { name, value } | undefined\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie probe: ${name} => missing`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.id ?? payload.sub ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          }\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") {\r\n            console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on cookie access — continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n          console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used inside route handlers.\r\n *\r\n * Example:\r\n *   const user = await requireRole(req, ['admin']);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 272, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/messages/send/route.ts"],"sourcesContent":["// app/api/messages/send/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getUserFromCookies } from \"@/lib/auth\"; // example — whatever you use\r\nimport { devLog } from \"@/lib/utils\";\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json();\r\n    const { to, messageBody, channel, contactId } = body;\r\n\r\n    const user = await getUserFromCookies(req);\r\n    const resolvedUserId = user?.id;\r\n\r\n    if (!resolvedUserId)\r\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\r\n\r\n   // ---------- Robust flow: ensure Contact -> ensure Thread -> create Message ----------\r\n\r\n/**\r\n * Assumptions:\r\n * - Your Prisma models expose prisma.contact, prisma.thread, prisma.message\r\n * - Contact unique id field is `id`. If your Contact uses a different unique field, adjust the queries below.\r\n * - Contact phone field guessed as `phone`. If yours is `phoneNumber` or `value`, change accordingly.\r\n */\r\n\r\nconst senderId = String(resolvedUserId);\r\n\r\n// Helper: normalize phone string for lookup (lightweight)\r\nfunction normalizePhone(p?: string | null) {\r\n  if (!p) return null;\r\n  // simple normalizer: remove spaces, parentheses, dashes\r\n  return p.replace(/[()\\s-]/g, \"\");\r\n}\r\n\r\nconst normalizedPhone = normalizePhone(to);\r\n\r\n// 1) Ensure contact exists\r\nlet contact: any = null;\r\ntry {\r\n  if (contactId) {\r\n    contact = await prisma.contact.findUnique({ where: { id: contactId } }).catch(() => null);\r\n    devLog(\"lookup contact by id:\", contactId, \"found:\", !!contact);\r\n  }\r\n\r\n  if (!contact && normalizedPhone) {\r\n    // Try to find contact by phone column (change field if yours differs)\r\n    // If your Contact schema uses `phoneNumber` or `value`, replace `phone` below.\r\n    contact = await prisma.contact.findFirst({\r\n      where: { phone: normalizedPhone },\r\n    }).catch(() => null);\r\n    devLog(\"lookup contact by phone:\", normalizedPhone, \"found:\", !!contact);\r\n  }\r\n\r\n  if (!contact) {\r\n    // Create minimal contact record so FK constraints succeed.\r\n    // IMPORTANT: change `phone` below to the actual required field name in your Contact model.\r\n    // If your Contact model has other required fields, add them here.\r\n    const createPayload: any = {\r\n      // If you want to keep given contactId as id, set it; else let Prisma generate.\r\n      ...(contactId ? { id: contactId } : {}),\r\n      phone: normalizedPhone ?? undefined,\r\n      // optionally add: name: \"Unknown\"\r\n    };\r\n\r\n    // Remove undefined keys\r\n    Object.keys(createPayload).forEach((k) => createPayload[k] === undefined && delete createPayload[k]);\r\n\r\n    contact = await prisma.contact.create({\r\n      data: createPayload,\r\n    });\r\n\r\n    devLog(\"created contact:\", contact?.id ?? \"(no id)\");\r\n  }\r\n} catch (err) {\r\n  console.error(\"[/api/messages/send] contact ensure failed:\", err);\r\n  return NextResponse.json({ error: \"Failed to ensure contact\" }, { status: 500 });\r\n}\r\n\r\n// 2) Find existing thread for the contact, else create a new thread\r\nlet thread: any = null;\r\ntry {\r\n  thread = await prisma.thread.findFirst({\r\n    where: { contactId: contact.id },\r\n    orderBy: { lastAt: \"desc\" },\r\n  });\r\n\r\n  if (!thread) {\r\n    // Create thread referencing the contactId scalar (contact now exists)\r\n    thread = await prisma.thread.create({\r\n      data: {\r\n        contactId: contact.id,\r\n        creatorId: senderId,\r\n        lastAt: new Date(),\r\n      } as any,\r\n    });\r\n    devLog(\"created thread:\", thread?.id ?? \"(no id)\");\r\n  } else {\r\n    devLog(\"found thread:\", thread.id);\r\n  }\r\n} catch (err) {\r\n  console.error(\"[/api/messages/send] thread ensure failed:\", err);\r\n  return NextResponse.json({ error: \"Failed to ensure thread\" }, { status: 500 });\r\n}\r\n\r\n// 3) Create the message attaching to the thread and sender\r\nlet message: any = null;\r\ntry {\r\n  // Prefer using scalar threadId if your Message model has it. If not, Prisma will accept\r\n  // nested relation connect: { id: thread.id } — both are fine. Use relation 'sender' connect.\r\n  const messageData: any = {\r\n    // If your Message model uses `threadId` scalar:\r\n    ...(typeof thread.id === \"string\" ? { threadId: thread.id } : {}),\r\n    // Also set nested thread connect in case your schema expects relation:\r\n    // comment out the next line if your Message model uses threadId scalar only.\r\n    thread: undefined, // we'll avoid nested create/connect if scalar threadId works\r\n    sender: { connect: { id: senderId } }, // relation connect\r\n    body: messageBody,\r\n    channel,\r\n    direction: \"OUTBOUND\",\r\n    metadata: { to },\r\n    // DO NOT include scheduledAt because your schema doesn't have it\r\n  };\r\n\r\n  // Remove undefined keys (like thread: undefined) so Prisma validation is clean\r\n  Object.keys(messageData).forEach((k) => messageData[k] === undefined && delete messageData[k]);\r\n\r\n  message = await prisma.message.create({\r\n    data: messageData,\r\n  });\r\n\r\n  devLog(\"created message:\", message?.id ?? \"(no id)\");\r\n\r\n  // 4) update thread.lastAt\r\n  try {\r\n    await prisma.thread.update({\r\n      where: { id: thread.id },\r\n      data: { lastAt: new Date() },\r\n    });\r\n  } catch (updateErr) {\r\n    devLog(\"failed to update thread.lastAt:\", updateErr?.message ?? updateErr);\r\n  }\r\n\r\n  return NextResponse.json({ ok: true, message, thread });\r\n} catch (err) {\r\n  console.error(\"[/api/messages/send] error creating message:\", err);\r\n  return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\r\n}\r\n\r\n  } catch (err) {\r\n    console.error(\"[/api/messages/send] uncaught:\", err);\r\n    return NextResponse.json({ error: \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}