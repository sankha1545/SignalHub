{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["\r\n\r\nimport { PrismaClient, type Prisma } from \"@prisma/client\";\r\n\r\ntype GlobalWithPrisma = typeof globalThis & {\r\n  prisma?: PrismaClient;\r\n};\r\n\r\n// Use the global object available in this runtime (node, edge, etc.)\r\nconst _global = globalThis as GlobalWithPrisma;\r\n\r\n// Decide whether we want query logging enabled.\r\n// This is intentionally opt-in via DEV_LOG_QUERIES to avoid noisy logs in normal dev.\r\nconst enableQueryLogging =\r\n  process.env.DEV_LOG_QUERIES === \"true\" && process.env.NODE_ENV !== \"production\";\r\n\r\nconst prismaOptions: Prisma.PrismaClientOptions = enableQueryLogging\r\n  ? { log: [\"query\"] }\r\n  : {};\r\n\r\n// Create or reuse the PrismaClient instance\r\nconst client = _global.prisma ?? new PrismaClient(prismaOptions);\r\n\r\n// In non-production environments, attach to global to avoid new clients on HMR\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  _global.prisma = client;\r\n}\r\n\r\n/**\r\n * Export named and default to be compatible with both import styles.\r\n */\r\nexport const prisma = client;\r\nexport default prisma;\r\n"],"names":[],"mappings":";;;;;;AAEA;;AAMA,qEAAqE;AACrE,MAAM,UAAU;AAEhB,gDAAgD;AAChD,sFAAsF;AACtF,MAAM,qBACJ,QAAQ,GAAG,CAAC,eAAe,KAAK,UAAU,oDAAyB;AAErE,MAAM,gBAA4C,qBAC9C;IAAE,KAAK;QAAC;KAAQ;AAAC,IACjB,CAAC;AAEL,4CAA4C;AAC5C,MAAM,SAAS,QAAQ,MAAM,IAAI,IAAI,6IAAY,CAAC;AAElD,+EAA+E;AAC/E,wCAA2C;IACzC,QAAQ,MAAM,GAAG;AACnB;AAKO,MAAM,SAAS;uCACP","debugId":null}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attackcapital/SignalHub/frontend/src/app/api/phone/verify-otp/route.ts"],"sourcesContent":["// app/api/phone/verify-otp/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\nfunction safeStringify(v: any) {\r\n  try { return JSON.stringify(v); } catch { return String(v); }\r\n}\r\n\r\nasync function fetchCurrentUserWithCookies(req: Request) {\r\n  // Build a base URL for internal fetch. Prefer forwarded proto/host; fall back to localhost:3000.\r\n  const host = req.headers.get(\"host\") || \"localhost:3000\";\r\n  const proto = (req.headers.get(\"x-forwarded-proto\") || (process.env.NODE_ENV === \"production\" ? \"https\" : \"http\")) as string;\r\n  const base = `${proto}://${host}`;\r\n  try {\r\n    const cookieHeader = req.headers.get(\"cookie\") || \"\";\r\n    const res = await fetch(`${base}/api/me`, {\r\n      headers: { cookie: cookieHeader },\r\n      cache: \"no-store\",\r\n    });\r\n    if (!res.ok) return null;\r\n    const j = await res.json().catch(() => null);\r\n    return j?.user ?? null;\r\n  } catch (e) {\r\n    console.warn(\"[verify-otp] /api/me fetch failed\", e);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json().catch(() => ({}));\r\n    const phone = (body?.phone ?? \"\").toString();\r\n    const otp = (body?.otp ?? \"\").toString();\r\n\r\n    if (!phone || !otp) {\r\n      return NextResponse.json({ error: \"Phone and OTP are required\" }, { status: 400 });\r\n    }\r\n\r\n    // Find latest unused OTP\r\n    const record = await prisma.phoneOtp.findFirst({\r\n      where: { phone, used: false },\r\n      orderBy: { createdAt: \"desc\" },\r\n    });\r\n\r\n    if (!record) {\r\n      return NextResponse.json({ error: \"No OTP found for this phone\" }, { status: 404 });\r\n    }\r\n\r\n    const now = Date.now();\r\n    const createdAt = new Date(record.createdAt).getTime();\r\n    if (now - createdAt > 5 * 60 * 1000) {\r\n      return NextResponse.json({ error: \"OTP expired. Please request a new one.\" }, { status: 400 });\r\n    }\r\n\r\n    if ((record.attempts ?? 0) >= 5) {\r\n      return NextResponse.json({ error: \"Too many attempts. Request new OTP.\" }, { status: 429 });\r\n    }\r\n\r\n    if (record.otp !== otp) {\r\n      await prisma.phoneOtp.update({\r\n        where: { id: record.id },\r\n        data: { attempts: (record.attempts ?? 0) + 1 },\r\n      });\r\n      return NextResponse.json({ error: \"Invalid OTP\" }, { status: 400 });\r\n    }\r\n\r\n    // mark used\r\n    await prisma.phoneOtp.update({ where: { id: record.id }, data: { used: true } });\r\n\r\n    // 1) Try to identify the currently authenticated user by calling internal /api/me with same cookies\r\n    const sessionUser = await fetchCurrentUserWithCookies(req);\r\n\r\n    let userToReturn = null;\r\n\r\n    if (sessionUser && sessionUser.id) {\r\n      // update the logged-in user's profile\r\n      const userId = sessionUser.id;\r\n\r\n      // Attempt to update profile fields safely.\r\n      // We'll try profile.upsert first (if you have a Profile model), otherwise update top-level fields.\r\n      try {\r\n        // Try to upsert profile (works if you have a Profile model related by userId)\r\n        await prisma.profile.upsert({\r\n          where: { userId },\r\n          create: {\r\n            userId,\r\n            // if your schema enforces required fields adjust accordingly\r\n            phoneNumber: phone as any,\r\n            phoneVerified: true as any,\r\n            phoneVerifiedAt: new Date(),\r\n          } as any,\r\n          update: {\r\n            phoneNumber: phone as any,\r\n            phoneVerified: true as any,\r\n            phoneVerifiedAt: new Date(),\r\n          } as any,\r\n        });\r\n      } catch (profileErr) {\r\n        // fallback: top-level user update if your schema stores phone on user table\r\n        try {\r\n          await prisma.user.update({\r\n            where: { id: userId },\r\n            data: {\r\n              // update top-level phone if present\r\n              phone: phone,\r\n            } as any,\r\n          });\r\n        } catch (uErr) {\r\n          // fallback: attempt to update profile.metadata JSON if profile/phone columns are missing\r\n          try {\r\n            const existing = await prisma.profile.findUnique({ where: { userId }, select: { metadata: true } });\r\n            const meta = { ...(existing?.metadata ?? {}), phone, phoneVerified: true, phoneVerifiedAt: new Date().toISOString() };\r\n            if (existing) {\r\n              await prisma.profile.update({ where: { userId }, data: { metadata: meta as any } as any } as any);\r\n            } else {\r\n              await prisma.profile.create({ data: { userId, metadata: meta as any } as any } as any);\r\n            }\r\n          } catch (metaErr) {\r\n            console.error(\"[verify-otp] profile fallback update failed\", metaErr);\r\n            // don't fail the whole request - we will still try to return a response\r\n          }\r\n        }\r\n      }\r\n\r\n      // fetch fresh user with profile\r\n      userToReturn = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: { id: true, email: true, name: true, role: true, profile: true, updatedAt: true },\r\n      });\r\n    } else {\r\n      // If no session user found, attempt to find user by phone or contact and update that user's profile\r\n      // Try top-level user.phone (if exists)\r\n      try {\r\n        const userByPhone = await prisma.user.findFirst({ where: { phone } as any, select: { id: true, email: true, name: true, profile: true } as any }).catch(() => null);\r\n        if (userByPhone) {\r\n          try {\r\n            await prisma.profile.upsert({\r\n              where: { userId: userByPhone.id },\r\n              create: { userId: userByPhone.id, phoneNumber: phone as any, phoneVerified: true as any, phoneVerifiedAt: new Date() } as any,\r\n              update: { phoneNumber: phone as any, phoneVerified: true as any, phoneVerifiedAt: new Date() } as any,\r\n            });\r\n          } catch {\r\n            // ignore and try metadata fallback\r\n            const existing = await prisma.profile.findUnique({ where: { userId: userByPhone.id }, select: { metadata: true } }).catch(() => null);\r\n            const meta = { ...(existing?.metadata ?? {}), phone, phoneVerified: true, phoneVerifiedAt: new Date().toISOString() };\r\n            if (existing) {\r\n              await prisma.profile.update({ where: { userId: userByPhone.id }, data: { metadata: meta as any } as any } as any);\r\n            } else {\r\n              await prisma.profile.create({ data: { userId: userByPhone.id, metadata: meta as any } as any } as any);\r\n            }\r\n          }\r\n          userToReturn = await prisma.user.findUnique({ where: { id: userByPhone.id }, select: { id: true, email: true, name: true, profile: true, updatedAt: true } });\r\n        }\r\n      } catch (e) {\r\n        console.warn(\"[verify-otp] userByPhone check failed\", e);\r\n      }\r\n\r\n      // If still no user, try contact table (if present)\r\n      if (!userToReturn) {\r\n        try {\r\n          const contact = await prisma.contact.findUnique({ where: { phone } as any }).catch(() => null);\r\n          if (contact && (contact as any).userId) {\r\n            const uid = (contact as any).userId;\r\n            try {\r\n              await prisma.profile.upsert({\r\n                where: { userId: uid },\r\n                create: { userId: uid, phoneNumber: phone as any, phoneVerified: true as any, phoneVerifiedAt: new Date() } as any,\r\n                update: { phoneNumber: phone as any, phoneVerified: true as any, phoneVerifiedAt: new Date() } as any,\r\n              });\r\n            } catch {\r\n              // metadata fallback\r\n              const existing = await prisma.profile.findUnique({ where: { userId: uid }, select: { metadata: true } }).catch(() => null);\r\n              const meta = { ...(existing?.metadata ?? {}), phone, phoneVerified: true, phoneVerifiedAt: new Date().toISOString() };\r\n              if (existing) {\r\n                await prisma.profile.update({ where: { userId: uid }, data: { metadata: meta as any } as any } as any);\r\n              } else {\r\n                await prisma.profile.create({ data: { userId: uid, metadata: meta as any } as any } as any);\r\n              }\r\n            }\r\n            userToReturn = await prisma.user.findUnique({ where: { id: uid }, select: { id: true, email: true, name: true, profile: true, updatedAt: true } });\r\n          }\r\n        } catch (cErr) {\r\n          console.warn(\"[verify-otp] contact lookup failed\", cErr);\r\n        }\r\n      }\r\n    }\r\n\r\n    // If still no userToReturn, create/ensure contact exists and return a minimal \"patch\" that UI can use\r\n    if (!userToReturn) {\r\n      try {\r\n        await prisma.contact.upsert({\r\n          where: { phone },\r\n          create: { phone, name: `unknown-${phone}` },\r\n          update: { phone },\r\n        });\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n\r\n      // Return non-failing success, but include a user-like patch so frontend can optimistically update UI\r\n      return NextResponse.json({\r\n        ok: true,\r\n        message: \"OTP verified but no user account linked to this session. Contact created in directory.\",\r\n        userPatch: {\r\n          profile: { phoneNumber: phone, phoneVerified: true, phoneVerifiedAt: new Date().toISOString() },\r\n        },\r\n      });\r\n    }\r\n\r\n    // Successful update -> return canonical user object with profile\r\n    return NextResponse.json({\r\n      ok: true,\r\n      message: \"Phone verified successfully\",\r\n      user: userToReturn,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"verify-otp error\", err);\r\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,oCAAoC;;;;;AACpC;AACA;;;AAEA,SAAS,cAAc,CAAM;IAC3B,IAAI;QAAE,OAAO,KAAK,SAAS,CAAC;IAAI,EAAE,OAAM;QAAE,OAAO,OAAO;IAAI;AAC9D;AAEA,eAAe,4BAA4B,GAAY;IACrD,iGAAiG;IACjG,MAAM,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,WAAW;IACxC,MAAM,QAAS,IAAI,OAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,sCAAwC,0BAAU,MAAM;IAChH,MAAM,OAAO,GAAG,MAAM,GAAG,EAAE,MAAM;IACjC,IAAI;QACF,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa;QAClD,MAAM,MAAM,MAAM,MAAM,GAAG,KAAK,OAAO,CAAC,EAAE;YACxC,SAAS;gBAAE,QAAQ;YAAa;YAChC,OAAO;QACT;QACA,IAAI,CAAC,IAAI,EAAE,EAAE,OAAO;QACpB,MAAM,IAAI,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,IAAM;QACvC,OAAO,GAAG,QAAQ;IACpB,EAAE,OAAO,GAAG;QACV,QAAQ,IAAI,CAAC,qCAAqC;QAClD,OAAO;IACT;AACF;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC7C,MAAM,QAAQ,CAAC,MAAM,SAAS,EAAE,EAAE,QAAQ;QAC1C,MAAM,MAAM,CAAC,MAAM,OAAO,EAAE,EAAE,QAAQ;QAEtC,IAAI,CAAC,SAAS,CAAC,KAAK;YAClB,OAAO,4JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA6B,GAAG;gBAAE,QAAQ;YAAI;QAClF;QAEA,yBAAyB;QACzB,MAAM,SAAS,MAAM,4IAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;YAC7C,OAAO;gBAAE;gBAAO,MAAM;YAAM;YAC5B,SAAS;gBAAE,WAAW;YAAO;QAC/B;QAEA,IAAI,CAAC,QAAQ;YACX,OAAO,4JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA8B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,YAAY,IAAI,KAAK,OAAO,SAAS,EAAE,OAAO;QACpD,IAAI,MAAM,YAAY,IAAI,KAAK,MAAM;YACnC,OAAO,4JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyC,GAAG;gBAAE,QAAQ;YAAI;QAC9F;QAEA,IAAI,CAAC,OAAO,QAAQ,IAAI,CAAC,KAAK,GAAG;YAC/B,OAAO,4JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsC,GAAG;gBAAE,QAAQ;YAAI;QAC3F;QAEA,IAAI,OAAO,GAAG,KAAK,KAAK;YACtB,MAAM,4IAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;gBAC3B,OAAO;oBAAE,IAAI,OAAO,EAAE;gBAAC;gBACvB,MAAM;oBAAE,UAAU,CAAC,OAAO,QAAQ,IAAI,CAAC,IAAI;gBAAE;YAC/C;YACA,OAAO,4JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAc,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,YAAY;QACZ,MAAM,4IAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;YAAE,OAAO;gBAAE,IAAI,OAAO,EAAE;YAAC;YAAG,MAAM;gBAAE,MAAM;YAAK;QAAE;QAE9E,oGAAoG;QACpG,MAAM,cAAc,MAAM,4BAA4B;QAEtD,IAAI,eAAe;QAEnB,IAAI,eAAe,YAAY,EAAE,EAAE;YACjC,sCAAsC;YACtC,MAAM,SAAS,YAAY,EAAE;YAE7B,2CAA2C;YAC3C,mGAAmG;YACnG,IAAI;gBACF,8EAA8E;gBAC9E,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;oBAC1B,OAAO;wBAAE;oBAAO;oBAChB,QAAQ;wBACN;wBACA,6DAA6D;wBAC7D,aAAa;wBACb,eAAe;wBACf,iBAAiB,IAAI;oBACvB;oBACA,QAAQ;wBACN,aAAa;wBACb,eAAe;wBACf,iBAAiB,IAAI;oBACvB;gBACF;YACF,EAAE,OAAO,YAAY;gBACnB,4EAA4E;gBAC5E,IAAI;oBACF,MAAM,4IAAM,CAAC,IAAI,CAAC,MAAM,CAAC;wBACvB,OAAO;4BAAE,IAAI;wBAAO;wBACpB,MAAM;4BACJ,oCAAoC;4BACpC,OAAO;wBACT;oBACF;gBACF,EAAE,OAAO,MAAM;oBACb,yFAAyF;oBACzF,IAAI;wBACF,MAAM,WAAW,MAAM,4IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;4BAAE,OAAO;gCAAE;4BAAO;4BAAG,QAAQ;gCAAE,UAAU;4BAAK;wBAAE;wBACjG,MAAM,OAAO;4BAAE,GAAI,UAAU,YAAY,CAAC,CAAC;4BAAG;4BAAO,eAAe;4BAAM,iBAAiB,IAAI,OAAO,WAAW;wBAAG;wBACpH,IAAI,UAAU;4BACZ,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gCAAE,OAAO;oCAAE;gCAAO;gCAAG,MAAM;oCAAE,UAAU;gCAAY;4BAAS;wBAC1F,OAAO;4BACL,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gCAAE,MAAM;oCAAE;oCAAQ,UAAU;gCAAY;4BAAS;wBAC/E;oBACF,EAAE,OAAO,SAAS;wBAChB,QAAQ,KAAK,CAAC,+CAA+C;oBAC7D,wEAAwE;oBAC1E;gBACF;YACF;YAEA,gCAAgC;YAChC,eAAe,MAAM,4IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;gBAC1C,OAAO;oBAAE,IAAI;gBAAO;gBACpB,QAAQ;oBAAE,IAAI;oBAAM,OAAO;oBAAM,MAAM;oBAAM,MAAM;oBAAM,SAAS;oBAAM,WAAW;gBAAK;YAC1F;QACF,OAAO;YACL,oGAAoG;YACpG,uCAAuC;YACvC,IAAI;gBACF,MAAM,cAAc,MAAM,4IAAM,CAAC,IAAI,CAAC,SAAS,CAAC;oBAAE,OAAO;wBAAE;oBAAM;oBAAU,QAAQ;wBAAE,IAAI;wBAAM,OAAO;wBAAM,MAAM;wBAAM,SAAS;oBAAK;gBAAS,GAAG,KAAK,CAAC,IAAM;gBAC9J,IAAI,aAAa;oBACf,IAAI;wBACF,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;4BAC1B,OAAO;gCAAE,QAAQ,YAAY,EAAE;4BAAC;4BAChC,QAAQ;gCAAE,QAAQ,YAAY,EAAE;gCAAE,aAAa;gCAAc,eAAe;gCAAa,iBAAiB,IAAI;4BAAO;4BACrH,QAAQ;gCAAE,aAAa;gCAAc,eAAe;gCAAa,iBAAiB,IAAI;4BAAO;wBAC/F;oBACF,EAAE,OAAM;wBACN,mCAAmC;wBACnC,MAAM,WAAW,MAAM,4IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;4BAAE,OAAO;gCAAE,QAAQ,YAAY,EAAE;4BAAC;4BAAG,QAAQ;gCAAE,UAAU;4BAAK;wBAAE,GAAG,KAAK,CAAC,IAAM;wBAChI,MAAM,OAAO;4BAAE,GAAI,UAAU,YAAY,CAAC,CAAC;4BAAG;4BAAO,eAAe;4BAAM,iBAAiB,IAAI,OAAO,WAAW;wBAAG;wBACpH,IAAI,UAAU;4BACZ,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gCAAE,OAAO;oCAAE,QAAQ,YAAY,EAAE;gCAAC;gCAAG,MAAM;oCAAE,UAAU;gCAAY;4BAAS;wBAC1G,OAAO;4BACL,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gCAAE,MAAM;oCAAE,QAAQ,YAAY,EAAE;oCAAE,UAAU;gCAAY;4BAAS;wBAC/F;oBACF;oBACA,eAAe,MAAM,4IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;wBAAE,OAAO;4BAAE,IAAI,YAAY,EAAE;wBAAC;wBAAG,QAAQ;4BAAE,IAAI;4BAAM,OAAO;4BAAM,MAAM;4BAAM,SAAS;4BAAM,WAAW;wBAAK;oBAAE;gBAC7J;YACF,EAAE,OAAO,GAAG;gBACV,QAAQ,IAAI,CAAC,yCAAyC;YACxD;YAEA,mDAAmD;YACnD,IAAI,CAAC,cAAc;gBACjB,IAAI;oBACF,MAAM,UAAU,MAAM,4IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;wBAAE,OAAO;4BAAE;wBAAM;oBAAS,GAAG,KAAK,CAAC,IAAM;oBACzF,IAAI,WAAW,AAAC,QAAgB,MAAM,EAAE;wBACtC,MAAM,MAAM,AAAC,QAAgB,MAAM;wBACnC,IAAI;4BACF,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gCAC1B,OAAO;oCAAE,QAAQ;gCAAI;gCACrB,QAAQ;oCAAE,QAAQ;oCAAK,aAAa;oCAAc,eAAe;oCAAa,iBAAiB,IAAI;gCAAO;gCAC1G,QAAQ;oCAAE,aAAa;oCAAc,eAAe;oCAAa,iBAAiB,IAAI;gCAAO;4BAC/F;wBACF,EAAE,OAAM;4BACN,oBAAoB;4BACpB,MAAM,WAAW,MAAM,4IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gCAAE,OAAO;oCAAE,QAAQ;gCAAI;gCAAG,QAAQ;oCAAE,UAAU;gCAAK;4BAAE,GAAG,KAAK,CAAC,IAAM;4BACrH,MAAM,OAAO;gCAAE,GAAI,UAAU,YAAY,CAAC,CAAC;gCAAG;gCAAO,eAAe;gCAAM,iBAAiB,IAAI,OAAO,WAAW;4BAAG;4BACpH,IAAI,UAAU;gCACZ,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;oCAAE,OAAO;wCAAE,QAAQ;oCAAI;oCAAG,MAAM;wCAAE,UAAU;oCAAY;gCAAS;4BAC/F,OAAO;gCACL,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;oCAAE,MAAM;wCAAE,QAAQ;wCAAK,UAAU;oCAAY;gCAAS;4BACpF;wBACF;wBACA,eAAe,MAAM,4IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;4BAAE,OAAO;gCAAE,IAAI;4BAAI;4BAAG,QAAQ;gCAAE,IAAI;gCAAM,OAAO;gCAAM,MAAM;gCAAM,SAAS;gCAAM,WAAW;4BAAK;wBAAE;oBAClJ;gBACF,EAAE,OAAO,MAAM;oBACb,QAAQ,IAAI,CAAC,sCAAsC;gBACrD;YACF;QACF;QAEA,sGAAsG;QACtG,IAAI,CAAC,cAAc;YACjB,IAAI;gBACF,MAAM,4IAAM,CAAC,OAAO,CAAC,MAAM,CAAC;oBAC1B,OAAO;wBAAE;oBAAM;oBACf,QAAQ;wBAAE;wBAAO,MAAM,CAAC,QAAQ,EAAE,OAAO;oBAAC;oBAC1C,QAAQ;wBAAE;oBAAM;gBAClB;YACF,EAAE,OAAO,GAAG;YACV,SAAS;YACX;YAEA,qGAAqG;YACrG,OAAO,4JAAY,CAAC,IAAI,CAAC;gBACvB,IAAI;gBACJ,SAAS;gBACT,WAAW;oBACT,SAAS;wBAAE,aAAa;wBAAO,eAAe;wBAAM,iBAAiB,IAAI,OAAO,WAAW;oBAAG;gBAChG;YACF;QACF;QAEA,iEAAiE;QACjE,OAAO,4JAAY,CAAC,IAAI,CAAC;YACvB,IAAI;YACJ,SAAS;YACT,MAAM;QACR;IACF,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,4JAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF","debugId":null}}]
}